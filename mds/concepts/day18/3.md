# Day 18 - 개념 3: 메시지 조회 및 전송 처리

채팅 애플리케이션에서 가장 중요한 부분은 메시지를 효율적으로 불러오고, 사용자가 입력한 메시지를 안전하게 서버에 저장하는 것입니다.

## 1. 메시지 기록 조회 및 페이지네이션

채팅방에는 수천 개의 메시지가 쌓일 수 있으므로, 모든 메시지를 한 번에 로드하는 것은 비효율적입니다. 페이지네이션(Pagination)을 사용하여 필요한 만큼의 메시지만 단계적으로 로드해야 합니다.

*   **일반적인 방향**: 사용자는 일반적으로 최신 메시지부터 확인하고 필요시 과거 메시지를 찾아봅니다. 따라서 UI는 최신 메시지가 하단에 표시되고, 스크롤을 위로 올리면 이전 메시지가 로드되는 방식이 자연스럽습니다.
*   **쿼리 전략**: `loader`에서는 최신 메시지부터 가져오도록 `ORDER BY created_at DESC`를 사용하고, UI에서는 받아온 배열을 뒤집거나(`reverse()`) CSS `flex-direction: column-reverse;` 등을 사용하여 시간 순서대로(오래된 것이 위, 최신 것이 아래) 표시합니다.
*   **페이지네이션 방법**:
    *   **커서 기반 (Cursor-based Pagination / Keyset Pagination)**:
        *   가장 효율적이고 권장되는 방식입니다. 상태 저장(stateless) 방식이며, 실시간 데이터 변경에도 안정적입니다.
        *   클라이언트는 마지막으로 로드된 메시지의 고유하고 정렬 가능한 값(예: `created_at` 타임스탬프 또는 고유 ID)을 "커서"로 기억합니다.
        *   다음 페이지(이전 메시지)를 로드할 때 이 커서를 서버(`loader`)로 보내고, 서버는 `WHERE created_at < :cursor` 와 같은 조건으로 커서보다 오래된 메시지 N개를 조회합니다.
        *   `created_at`이 중복될 수 있으므로, 고유성을 보장하기 위해 보조 정렬 기준으로 `id` (예: `ORDER BY created_at DESC, id DESC`)를 함께 사용하는 것이 좋습니다.
    *   **오프셋 기반 (Offset-based Pagination / Page Number)**:
        *   `LIMIT`과 `OFFSET` (또는 Supabase의 `range(from, to)`)을 사용합니다. 구현이 간단하지만, 데이터가 자주 변경되는 환경(새 메시지 도착 등)에서는 페이지 중복 또는 누락 문제가 발생할 수 있고, 데이터가 많아질수록 뒤 페이지 로딩 성능이 저하될 수 있습니다. 채팅에는 일반적으로 커서 기반이 더 적합합니다.
*   **무한 스크롤 (Infinite Scrolling)**:
    *   사용자가 메시지 목록의 상단(또는 하단)에 도달하면 자동으로 다음 페이지(이전 또는 이후 메시지)를 로드하는 UI 패턴입니다.
    *   Remix에서는 `useFetcher`를 사용하여 `loader` 함수를 트리거하고 추가 데이터를 비동기적으로 로드하여 기존 목록에 병합할 수 있습니다. Intersection Observer API 등을 사용하여 스크롤 위치 감지를 효율적으로 구현할 수 있습니다.

## 2. 메시지 입력 및 전송 처리

사용자가 입력한 메시지를 서버로 보내고 데이터베이스에 저장하는 과정입니다.

*   **클라이언트 (UI)**:
    *   메시지 입력 필드 (`<input>`, `<textarea>`)와 전송 버튼 (`<button type="submit">`)을 `<Form>` 또는 `fetcher.Form` 내부에 배치합니다.
    *   `fetcher.Form`을 사용하면 페이지 전체 리프레시 없이 액션을 호출하고, Optimistic UI 구현이 용이합니다.
    *   사용자 경험을 위해 엔터 키 입력 시 전송 (Shift+Enter는 줄바꿈) 등의 기능을 추가할 수 있습니다.
*   **서버 (Remix Action)**:
    *   `action` 함수는 `request` 객체를 통해 폼 데이터를 받습니다.
    *   **인증 및 권한 부여**: 현재 로그인된 사용자인지 확인합니다. (`createServerClient` 활용)
    *   **입력 유효성 검사**: 메시지 내용이 비어있지 않은지, 너무 길지 않은지 등을 검사합니다.
    *   **데이터베이스 저장**: 유효성 검사를 통과하면 `messages` 테이블에 새 레코드를 INSERT합니다.
        *   `room_id`: 현재 채팅방 ID (URL 파라미터 또는 hidden input)
        *   `user_id`: 현재 로그인된 사용자 ID (`user.id`)
        *   `content`: 유효성 검사를 통과한 메시지 내용
        *   RLS (Row Level Security) 정책: `messages` 테이블의 INSERT 정책은 반드시 `user_id`가 `auth.uid()`와 같고, 사용자가 해당 `room_id`에 참여하고 있는지 확인해야 합니다. 이를 통해 악의적인 사용자가 다른 사람의 이름으로 메시지를 보내거나, 참여하지 않은 방에 메시지를 보내는 것을 방지합니다.
    *   **결과 반환**: 성공 시 `null` 또는 성공 상태를, 실패 시 에러 메시지와 함께 `json` 응답을 반환합니다.
*   **Optimistic UI (선택적)**:
    *   `fetcher.Form` 사용 시, 메시지 전송 요청을 보내는 즉시 UI에 해당 메시지를 임시로 추가하여 사용자가 즉각적인 피드백을 받도록 할 수 있습니다. 서버 응답 후 실제 데이터와 동기화하거나 실패 시 임시 메시지를 제거합니다. 이는 사용자 경험을 크게 향상시킵니다. (Day 16 개념 참고)

## 3. 기본적인 채팅 UI 패턴

*   **메시지 버블**: 각 메시지를 말풍선 형태로 표시합니다.
*   **발신자 구분**: 자신이 보낸 메시지와 상대방이 보낸 메시지를 시각적으로 구분합니다. (예: 오른쪽/왼쪽 정렬, 다른 배경색)
*   **아바타 표시**: 메시지 옆에 발신자의 프로필 아바타를 표시합니다. 연속된 메시지에서는 첫 메시지에만 표시하는 등 간결하게 표현할 수 있습니다.
*   **타임스탬프**: 메시지 수신 또는 발신 시간을 표시합니다. (예: 메시지 옆, 날짜 변경 시 날짜 구분선 추가)
*   **스크롤 관리**: 채팅방 진입 시 또는 새 메시지 수신 시 스크롤을 맨 아래로 이동시켜 최신 내용을 보여줍니다.

효율적인 데이터 로딩과 안전한 전송 처리는 실시간 채팅 기능의 기반이 됩니다. 다음 단계에서는 Supabase Realtime을 연동하여 새 메시지를 실시간으로 받아오는 기능을 구현합니다. 