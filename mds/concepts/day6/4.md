# 작업 4 개념: DB 기반 동적 메뉴 구현

애플리케이션의 네비게이션 메뉴를 사용자의 역할과 권한에 따라 동적으로 보여주는 것은 사용자 경험과 보안 측면에서 중요합니다. 이 작업은 데이터베이스(DB)를 활용하여 이러한 동적 메뉴 시스템을 구현하는 방법을 다룹니다.

## 왜 DB 기반 메뉴인가?

*   **중앙 관리 및 유지보수:** 메뉴 항목(이름, 경로, 아이콘 등)과 각 메뉴에 접근 가능한 사용자 역할/권한 정보를 DB에서 일괄 관리합니다. 메뉴 구조 변경, 추가, 삭제 또는 권한 변경 시 프론트엔드 코드를 수정할 필요 없이 DB 데이터만 업데이트하면 되므로 유지보수가 용이합니다.
*   **유연성 및 확장성:** 사용자 역할이 다양해지거나 메뉴별 접근 권한 규칙이 복잡해질 때, DB 기반 시스템은 프론트엔드 조건문 방식보다 훨씬 유연하게 대응할 수 있습니다. 새로운 메뉴나 역할을 추가하기 쉽습니다.
*   **보안 강화 (RLS 활용):** Supabase의 RLS(Row Level Security) 기능을 메뉴 관련 테이블에 적용하면, 데이터베이스 레벨에서 현재 사용자의 역할에 맞는 메뉴 데이터만 조회되도록 강제할 수 있습니다. 이는 서버 로직에서의 실수를 방지하고 보안을 강화하는 데 도움이 됩니다.

## 구현 흐름 (Remix 기준)

1.  **DB 스키마 설계:** 메뉴 정보(`menus`), 사용자 역할(`roles`), 역할별 메뉴 접근 권한(`role_menu_permissions`)을 저장할 테이블 구조를 설계합니다. 각 테이블 간의 관계(예: Foreign Key)를 정의하고, 필요에 따라 RLS 정책을 설정합니다.
2.  **서버 측 데이터 로딩 (`loader`):** 사용자가 페이지에 접근할 때 Remix의 `loader` 함수가 실행됩니다. 이 함수 내에서 현재 요청을 보낸 사용자의 역할 또는 권한을 파악합니다. (예: 세션 쿠키, 토큰 검증 등)
3.  **권한 기반 메뉴 조회:** 파악된 사용자 역할을 기준으로, 해당 역할이 접근할 수 있는 메뉴 목록을 DB에서 조회합니다. RLS 정책이 설정되어 있다면 간단히 `SELECT` 쿼리를 실행하는 것만으로도 자동으로 필터링된 결과가 반환될 수 있습니다.
4.  **데이터 전달:** `loader` 함수는 조회된 메뉴 데이터를 JSON 형태로 반환합니다. 이 데이터는 일반적으로 애플리케이션 전역에서 접근 가능해야 하므로, `app/root.tsx`의 `loader`나 공통 레이아웃의 `loader`에서 처리하는 경우가 많습니다.
5.  **프론트엔드 렌더링 (`Header` 등):** 메뉴를 표시하는 컴포넌트(예: `Header.tsx`)에서는 Remix의 `useLoaderData` 또는 `useMatches` 훅을 사용하여 `loader`가 전달한 메뉴 데이터를 가져옵니다. 이 데이터를 기반으로 반복문(`map`) 등을 사용하여 동적으로 메뉴 링크를 생성하고 화면에 렌더링합니다.

이 방식을 통해 메뉴 관리가 중앙화되고, 사용자 권한에 따라 적절한 메뉴만 노출되어 보다 안전하고 유지보수하기 쉬운 애플리케이션을 구축할 수 있습니다. 