# Day 16 - 개념 1: 데이터베이스 제약 조건과 관계 모델링

`upvotes` 테이블 스키마를 정의하면서 여러 데이터베이스 제약 조건과 관계 모델링 개념이 사용되었습니다. 이를 이해하는 것은 데이터의 무결성을 유지하고 정확한 애플리케이션 로직을 구현하는 데 중요합니다.

## 1. 기본 키 (Primary Key - PK)

*   **정의**: 테이블 내 각 레코드(행)를 고유하게 식별하는 컬럼 또는 컬럼들의 집합입니다.
*   **특징**:\n    *   `UNIQUE`: 기본 키 값은 테이블 내에서 항상 고유해야 합니다.\n    *   `NOT NULL`: 기본 키 컬럼은 `NULL` 값을 가질 수 없습니다.\n*   **`upvotes` 테이블**: `id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY`\n    *   `id` 컬럼을 기본 키로 사용합니다.\n    *   `BIGINT`: 큰 정수 값을 저장할 수 있는 데이터 타입입니다.\n    *   `GENERATED BY DEFAULT AS IDENTITY`: PostgreSQL의 기능으로, 새 레코드가 삽입될 때마다 자동으로 고유한 순차 번호를 생성하여 `id` 컬럼에 할당합니다. (이전 버전의 `SERIAL`과 유사하지만 표준 SQL에 더 가깝습니다.)\n*   **대안 (복합 기본 키 - Composite PK)**: 두 개 이상의 컬럼을 조합하여 기본 키를 만들 수도 있습니다 (예: `PRIMARY KEY (user_id, product_id)`). 하지만 복합 PK는 모든 컬럼이 `NOT NULL`이어야 하고, 외래 키 설정 등이 더 복잡해질 수 있습니다. `upvotes` 테이블에서는 `product_id` 또는 `post_id`가 `NULL`일 수 있으므로, 복합 PK보다는 별도의 `id` 컬럼을 사용하는 것이 더 적합합니다.\n\n## 2. 외래 키 (Foreign Key - FK)\n\n*   **정의**: 한 테이블의 컬럼(또는 컬럼들)이 다른 테이블의 기본 키를 참조하는 제약 조건입니다. 테이블 간의 관계를 설정하고 데이터 무결성을 강제합니다.\n*   **`upvotes` 테이블**:\n    *   `user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE`\n        *   `upvotes.user_id`는 `profiles.id`를 참조합니다. 즉, `upvotes` 테이블에 존재하는 `user_id`는 반드시 `profiles` 테이블에도 존재해야 합니다.\n        *   `ON DELETE CASCADE`: 참조되는 `profiles` 레코드가 삭제될 경우, 해당 `user_id`를 가진 `upvotes` 레코드도 자동으로 함께 삭제됩니다. (사용자 탈퇴 시 추천 기록 자동 삭제)\n    *   `product_id BIGINT REFERENCES public.products(id) ON DELETE CASCADE`\n        *   `upvotes.product_id`는 `products.id`를 참조합니다. (단, `NULL` 허용)\n        *   제품이 삭제되면 관련 추천 기록도 삭제됩니다.\n    *   `post_id BIGINT REFERENCES public.posts(id) ON DELETE CASCADE`\n        *   `upvotes.post_id`는 `posts.id`를 참조합니다. (단, `NULL` 허용)\n        *   게시글이 삭제되면 관련 추천 기록도 삭제됩니다.\n*   **참조 무결성**: 외래 키는 존재하지 않는 사용자, 제품, 게시글에 대한 추천이 기록되는 것을 방지합니다.\n\n## 3. 유니크 제약 조건 (Unique Constraint)\n\n*   **정의**: 특정 컬럼 또는 컬럼 조합의 값이 테이블 내에서 항상 고유해야 함을 보장하는 제약 조건입니다. 기본 키와 유사하지만, `NULL` 값을 허용할 수 있습니다 (단, `NULL` 값 자체는 여러 번 나타날 수 있음 - DB 시스템마다 동작 상이할 수 있음).\n*   **`upvotes` 테이블**:\n    *   `CONSTRAINT unique_user_product_upvote UNIQUE (user_id, product_id)`\n        *   `user_id`와 `product_id`의 조합은 테이블 내에서 유일해야 합니다. 이를 통해 한 사용자가 동일한 제품을 여러 번 추천하는 것을 방지합니다.\n        *   `product_id`가 `NULL`인 레코드들은 이 제약 조건의 검사 대상이 아닙니다. (PostgreSQL의 `UNIQUE` 제약 조건은 `NULL`을 고유하지 않은 값으로 취급합니다.)\n    *   `CONSTRAINT unique_user_post_upvote UNIQUE (user_id, post_id)`\n        *   `user_id`와 `post_id`의 조합은 테이블 내에서 유일해야 합니다. 한 사용자가 동일한 게시글을 여러 번 추천하는 것을 방지합니다.\n        *   `post_id`가 `NULL`인 레코드들은 이 제약 조건의 검사 대상이 아닙니다.\n\n## 4. 체크 제약 조건 (Check Constraint)\n\n*   **정의**: 컬럼에 입력될 수 있는 값의 조건을 명시하는 제약 조건입니다. 특정 조건을 만족하는 데이터만 허용합니다.\n*   **`upvotes` 테이블**:\n    *   `CONSTRAINT check_resource_id CHECK (product_id IS NOT NULL OR post_id IS NOT NULL)`\n        *   `upvotes` 테이블에 레코드를 삽입하거나 수정할 때, `product_id` 컬럼 또는 `post_id` 컬럼 둘 중 적어도 하나는 `NULL`이 아닌 값을 가져야 한다는 조건을 강제합니다.\n        *   이는 추천 기록이 어떤 리소스(제품 또는 게시글)에 대한 것인지 명확히 하도록 보장합니다.\n\n## 5. 인덱스 (Index)\n\n*   **정의**: 데이터베이스 테이블에서 특정 컬럼(들)의 값을 기반으로 데이터 검색 속도를 향상시키는 데이터 구조입니다. 책의 색인과 유사한 역할을 합니다.\n*   **`upvotes` 테이블**:\n    *   `CREATE INDEX idx_upvotes_user_id ON public.upvotes(user_id);`\n    *   `CREATE INDEX idx_upvotes_product_id ON public.upvotes(product_id);`\n    *   `CREATE INDEX idx_upvotes_post_id ON public.upvotes(post_id);`\n    *   `WHERE` 절이나 `JOIN` 조건에서 자주 사용되는 `user_id`, `product_id`, `post_id` 컬럼에 인덱스를 생성하여 특정 사용자의 추천 목록 조회, 특정 제품/게시글의 추천 수 집계 등의 성능을 향상시킵니다.\n*   **참고**: 기본 키와 유니크 제약 조건은 일반적으로 자동으로 해당 컬럼(들)에 대한 인덱스를 생성합니다. 위 예시에서는 외래 키 컬럼에도 명시적으로 인덱스를 추가했습니다.\n\n## 6. 관계 모델링 고려사항 (다대다 관계)\n\n*   '사용자'와 '제품' 간의 추천 관계는 **다대다(Many-to-Many)** 관계입니다. 한 명의 사용자는 여러 제품을 추천할 수 있고, 하나의 제품은 여러 사용자에게 추천받을 수 있습니다.\n*   마찬가지로 '사용자'와 '게시글' 간의 추천 관계도 다대다 관계입니다.\n*   데이터베이스에서 다대다 관계는 직접 표현하기 어렵기 때문에, 중간에 **연결 테이블(Junction Table 또는 Associative Table)**을 두어 표현합니다. `upvotes` 테이블이 바로 이 연결 테이블 역할을 수행하며, 각 관계(사용자-제품 추천, 사용자-게시글 추천)를 기록합니다.\n\n이러한 데이터베이스 제약 조건과 관계 모델링 원칙을 적용함으로써, `upvotes` 테이블은 데이터의 정확성과 일관성을 유지하며 효율적인 추천 기능 구현의 기반을 마련합니다. 