# Day 16 - 개념 3: Remix `useFetcher` 훅 이해하기\n\nRemix의 `useFetcher` 훅은 현재 페이지의 URL 변경 없이(즉, 네비게이션 없이) 백그라운드에서 `loader`나 `action` 함수와 상호작용할 수 있게 해주는 강력한 도구입니다. 이는 \"좋아요\" 버튼, 뉴스레터 구독 폼, 자동 저장 기능 등 페이지의 주요 내용과 직접적인 관련이 없는 데이터 로딩이나 변경 작업에 매우 유용합니다.\n\n## 1. `useFetcher` 란?\n\n*   **네비게이션 없는 데이터 상호작용**: `useFetcher`를 사용하면, 일반적인 `<Form>` 제출이나 `<Link>` 클릭과 달리 브라우저의 URL이 변경되거나 전체 페이지 데이터가 다시 로드되지 않습니다. 오직 해당 `fetcher`와 연결된 `action`이나 `loader`만 백그라운드에서 실행됩니다.\n*   **독립적인 상태 관리**: 각 `fetcher` 인스턴스는 자체적인 상태(`state`, `data`, `formData`)를 가집니다. 이를 통해 여러 개의 독립적인 비동기 작업을 한 페이지 내에서 동시에 관리할 수 있습니다.\n*   **컴포넌트 기반**: `useFetcher`는 특정 컴포넌트 내에서 호출되어 해당 컴포넌트의 로직과 긴밀하게 연결됩니다. (예: `UpvoteButton` 컴포넌트 내에서 추천 액션 관리)\n\n## 2. `useFetcher`의 주요 속성 및 메서드\n\n`useFetcher()` 훅은 다음과 같은 주요 속성과 메서드를 가진 객체를 반환합니다.\n\n*   **`fetcher.Form`**: 네비게이션을 유발하지 않는 특수한 `<Form>` 컴포넌트입니다. 이 폼을 제출하면 연결된 `fetcher` 인스턴스의 상태가 업데이트됩니다. 일반 `<Form>`과 동일하게 `method`, `action`, `encType` 등의 속성을 사용할 수 있습니다.\n*   **`fetcher.submit(target, options)`**: 프로그래매틱하게(코드로) 폼 제출을 트리거합니다.\n    *   `target`: 전송할 데이터 (`FormData`, `URLSearchParams`, `object`) 또는 폼 요소 자체(`HTMLFormElement`).\n    *   `options`: `method`, `action`, `encType` 등 제출 옵션을 지정하는 객체.\n*   **`fetcher.load(href)`**: 네비게이션 없이 특정 URL의 `loader` 함수를 호출하고 그 결과를 `fetcher.data`에 로드합니다. 검색 결과 미리보기나 동적 데이터 로딩 등에 유용합니다.\n*   **`fetcher.state`**: 현재 `fetcher`의 상태를 나타내는 문자열입니다.\n    *   `\'idle\'`: 아무 작업도 수행하지 않는 기본 상태.\n    *   `\'submitting\'`: `action`으로 데이터가 전송 중인 상태 (`fetcher.Form` 제출 또는 `fetcher.submit` 호출 시).\n    *   `\'loading\'`: `action` 완료 후 데이터를 기다리거나, `fetcher.load` 호출 후 데이터를 로드 중인 상태.\n*   **`fetcher.data`**: 가장 최근에 성공적으로 완료된 `action` 또는 `loader` 호출이 반환한 데이터입니다. `action`이 `json()`으로 데이터를 반환했거나, `fetcher.load()`가 데이터를 로드했을 때 이 속성에 값이 채워집니다.\n*   **`fetcher.formData`**: 현재 `submitting` 상태일 때 전송 중인 `FormData` 객체입니다. Optimistic UI 구현 시 사용자가 제출한 데이터에 접근하는 데 유용합니다.\n*   **`fetcher.type`**: 현재 `fetcher`의 상태가 어떤 종류의 작업(초기화, 데이터 로드, 액션 호출 등)에 의한 것인지 나타냅니다. (`\'init\'`, `\'normalLoad\'`, `\'actionSubmission\'`, `\'actionReload\'`, `\'actionRedirect\'`, `\'loaderSubmission\'`, `\'done\'`)\n\n## 3. 일반 `<Form>` vs. `<fetcher.Form>`\n\n| 특징             | `<Form>` (일반 폼)                                  | `<fetcher.Form>` (`useFetcher` 사용)                      |\n| :--------------- | :-------------------------------------------------- | :-------------------------------------------------------- |\n| **네비게이션**   | 발생함 (URL 변경 가능, 히스토리 스택 추가)          | 발생하지 않음 (URL 유지, 히스토리 스택 영향 없음)           |\n| **데이터 로딩**  | Action 완료 후 현재 페이지의 `loader` **자동 재실행** | Action 완료 후 `loader` **자동 재실행 안 함**             |\n| **UI 업데이트**  | `loader` 재실행 결과를 기반으로 **페이지 전체** 업데이트 | `fetcher.data`나 다른 상태 변화를 기반으로 **부분적** 업데이트 필요 |\n| **상태 관리**    | `useNavigation`, `useActionData` 등 전역 상태 사용  | `fetcher` 객체 내의 지역 상태 사용 (`fetcher.state`, `fetcher.data`) |\n| **주요 사용 사례** | 페이지 이동을 동반하는 데이터 변경 (로그인, 생성 후 상세 이동 등) | 페이지 이동 없는 백그라운드 데이터 변경/로드 (좋아요, 자동 완성 등) |\n\n## 4. `useFetcher` 사용 시나리오\n\n*   **데이터 변경 (Mutations)**:\n    *   \'좋아요\', \'추천\', \'북마크\' 등 토글 기능\n    *   목록에서 항목 삭제 버튼\n    *   간단한 설정 값 업데이트\n    *   자동 저장 기능\n*   **데이터 로딩 (Loads)**:\n    *   사용자 입력에 따른 자동 완성 제안 (`fetcher.load`)\n    *   마우스를 올렸을 때 상세 정보 미리보기 (`fetcher.load`)\n    *   화면의 특정 부분만 동적으로 데이터 로드\n\n## 5. 주의사항 및 고려사항\n\n*   **UI 즉시 업데이트 부재**: `<fetcher.Form>`은 네비게이션을 발생시키지 않으므로 `loader`가 자동으로 다시 실행되지 않습니다. 따라서 Action 성공 후 UI가 즉시 반영되지 않을 수 있습니다. 이를 해결하기 위해 **Optimistic UI** (다음 작업) 또는 수동 데이터 갱신 로직이 필요합니다.\n*   **타입 안정성**: `useFetcher<T>()` 처럼 제네릭을 사용하여 `fetcher.data`의 타입을 명시하면 타입 안정성을 높일 수 있습니다. Action 함수의 반환 타입을 export하여 사용하거나, 예상되는 데이터 구조를 직접 정의할 수 있습니다.\n*   **에러 처리**: `fetcher.data`에 Action이 반환한 에러 정보를 담아 UI에 표시하거나, `useEffect` 등을 사용하여 에러 발생 시 부가적인 처리(예: 토스트 메시지)를 할 수 있습니다.\n\n`useFetcher`는 Remix 애플리케이션의 사용자 경험을 크게 향상시킬 수 있는 중요한 도구입니다. 페이지 전체 리로드 없이 필요한 데이터만 주고받음으로써 더 빠르고 부드러운 인터페이스를 만들 수 있습니다. 