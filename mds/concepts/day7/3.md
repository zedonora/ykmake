# 작업 3 개념: 동적 라우트와 URL 파라미터를 이용한 카테고리 페이지 (데이터 로딩 포함)

이 작업은 Remix의 동적 라우트 기능을 활용하여 다양한 카테고리에 대한 페이지를 하나의 파일로 처리하는 방법을 보여줍니다. 사용자가 특정 카테고리 URL(예: `/category/frontend`)로 접속하면, 해당 카테고리와 관련된 정보를 보여주는 페이지를 동적으로 생성합니다.

## 핵심 개념

1.  **동적 라우트 세그먼트:**
    *   Remix 라우트 파일 이름에 달러 기호(`$`) 접두사를 사용하면 해당 부분이 URL의 동적 세그먼트(파라미터)가 됩니다. (예: `app/routes/category.$categorySlug.tsx`)
    *   사용자가 `/category/react`로 접속하면 `$categorySlug`는 `"react"` 값을 가집니다. `/category/design-systems`로 접속하면 `$categorySlug`는 `"design-systems"`가 됩니다.
    *   이를 통해 수많은 카테고리 페이지를 각각 만들 필요 없이 하나의 파일로 관리할 수 있어 효율적입니다.

2.  **URL 파라미터 접근:**
    *   **`loader` 함수:** `loader` 함수는 첫 번째 인자인 `LoaderFunctionArgs` 객체를 통해 URL 파라미터에 접근할 수 있습니다. `params` 객체 (예: `params.categorySlug`)를 통해 동적 세그먼트의 값을 얻습니다.
    *   **UI 컴포넌트:** 페이지 컴포넌트 내에서는 Remix의 `useParams` 훅을 사용하여 현재 URL의 파라미터 값을 가져올 수 있습니다. 이는 `loader`를 거치지 않고 컴포넌트 레벨에서 파라미터 값이 필요할 때 유용합니다.

3.  **동적 데이터 로딩 (`loader` 구현):**
    *   `jobs/day7/3.md`의 `loader` 함수는 `params.categorySlug` 값을 사용하여 **실제 데이터베이스 조회**를 수행합니다.
    *   Drizzle `db` 클라이언트를 사용하여 `jobs` 테이블에서 `category` 컬럼 값이 `categorySlug`와 일치하는(`where(eq(jobs.category, categorySlug))`) 레코드들을 조회합니다.
    *   조회된 관련 데이터 목록(`categoryJobs`)을 `categorySlug`와 함께 `json` (또는 `Response.json`)으로 반환합니다.
    *   **확장성:** 향후 이 `loader`는 `jobs` 뿐만 아니라 `community_posts`, `ideas_gpt` 등 다른 테이블에서도 동일한 `categorySlug`로 데이터를 조회하여 여러 종류의 관련 정보를 함께 반환하도록 확장될 수 있습니다.

4.  **동적 메타 태그 (`meta` 함수):**
    *   페이지의 검색 엔진 최적화(SEO) 및 브라우저 탭 제목 표시를 위해 `meta` 함수를 사용합니다.
    *   `meta` 함수는 `loader`가 반환한 데이터(`data`)에 접근할 수 있습니다. 이를 활용하여 `data.categorySlug` 값을 이용해 각 카테고리 페이지에 맞는 동적인 제목(`title`)과 설명(`description`)을 설정합니다. (예: "React 카테고리 | YkMake")

5.  **URL 파라미터 유효성 검사 (Zod):**
    *   URL 파라미터는 사용자가 임의로 입력할 수 있으므로, `loader` 함수 초기에 Zod 스키마(`ParamsSchema`)를 사용하여 예상하는 형식(예: 문자열, 최소 길이)인지 검증하는 것이 안전합니다.
    *   유효하지 않은 파라미터가 들어오면 오류 응답(예: 400 Bad Request)을 반환하여 잘못된 요청을 처리합니다.

6.  **UI 구현 (데이터 렌더링):**
    *   페이지 컴포넌트에서는 `useLoaderData` 훅을 사용하여 `loader`가 반환한 `categorySlug`와 `categoryJobs` 데이터를 가져옵니다.
    *   가져온 `categoryName`을 페이지 제목 등으로 표시합니다.
    *   `categoryJobs` 배열을 `map` 함수로 순회하며 각 Job 정보를 목록 형태로 렌더링합니다.
    *   데이터가 없을 경우 "표시할 항목이 없습니다"와 같은 메시지를 보여줍니다.

이러한 동적 라우트 패턴은 카테고리뿐만 아니라 사용자 프로필 페이지(`/users/$userId`), 제품 상세 페이지(`/products/$productId`) 등 다양한 상황에서 재사용될 수 있는 중요한 개발 기법입니다.

## 관련 코드 변경: ThemeToggle 컴포넌트 위치 이동

*   기존에 `app/root.tsx` 파일의 최상위 레이아웃에 직접 배치되었던 `ThemeToggle` 컴포넌트 (라이트/다크 모드 전환 버튼)가 사용자 인터페이스의 일관성을 위해 `app/components/layout/Header.tsx` 컴포넌트 내부로 이동되었습니다.
*   이 변경은 전역 레이아웃(`root.tsx`)을 단순화하고, 헤더와 관련된 UI 요소들을 `Header.tsx` 컴포넌트에서 중앙 관리하도록 합니다.
*   `Header.tsx` 파일에서 `ThemeToggle` 컴포넌트를 임포트하고, 헤더의 우측 영역 (로그인/로그아웃 버튼 옆)에 배치했습니다. 

# Day 7 - 개념 3: 동적 라우트와 URL 파라미터를 이용한 데이터 필터링

`jobs/day7/3.md`에서 구현한 카테고리별 페이지는 Remix의 **동적 라우트(Dynamic Routes)** 와 URL 파라미터를 활용하여 특정 조건에 맞는 데이터만 필터링하여 보여주는 일반적인 웹 애플리케이션 패턴을 보여줍니다.

## 1. 동적 라우트 세그먼트 (`$` Prefix)

Remix에서 파일명이나 디렉토리명 앞에 `$` 기호를 붙이면 해당 부분이 **동적 세그먼트**가 됩니다. 이 세그먼트는 URL 경로의 일부를 변수처럼 취급하게 해줍니다.

*   **파일명 예시:** `app/routes/users.$userId.tsx`
    *   `/users/123`, `/users/abc` 와 같은 경로와 매칭됩니다.
    *   `userId` 라는 이름으로 `123`, `abc` 값을 파라미터로 사용할 수 있습니다.
*   **디렉토리명 예시:** `app/routes/products/$productId/reviews.tsx`
    *   `/products/xyz/reviews` 와 같은 경로와 매칭됩니다.
    *   `productId` 라는 이름으로 `xyz` 값을 파라미터로 사용할 수 있습니다.
*   **우리가 사용한 예시:** `app/routes/categories.$slug.tsx`
    *   `/categories/development`, `/categories/design` 등과 매칭됩니다.
    *   `slug` 라는 이름으로 `development`, `design` 값을 파라미터로 사용할 수 있습니다.

## 2. `loader` 함수에서 URL 파라미터 접근 및 사용

`loader` 함수는 인자로 `LoaderFunctionArgs` 객체를 받으며, 이 객체 안의 `params` 속성을 통해 동적 세그먼트의 값을 얻을 수 있습니다.

```typescript
import type { LoaderFunctionArgs } from '@remix-run/node';
import { db } from '~/db/drizzle.server';
import { jobs } from '~/db/schema';
import { eq } from 'drizzle-orm'; // 'equals' 조건을 위한 Drizzle 함수

export async function loader({ params }: LoaderFunctionArgs) {
  // params 객체에서 동적 세그먼트 이름('slug')으로 값 추출
  const categorySlug = params.slug;

  // 기본적인 유효성 검사 (값이 없는 경우)
  if (!categorySlug) {
    throw new Response('Category not specified', { status: 400 });
  }

  // 추출한 파라미터(categorySlug)를 데이터베이스 쿼리의 조건으로 사용
  const jobList = await db
    .select()
    .from(jobs)
    // jobs 테이블의 category 컬럼 값이 categorySlug와 같은(eq) 레코드만 선택
    .where(eq(jobs.category, categorySlug))
    .orderBy(/* ... */)
    .limit(/* ... */);

  // 결과 데이터와 함께 파라미터 값(카테고리 이름)도 반환하여 UI에서 사용
  return Response.json({ jobList, categoryName: categorySlug });
}
```

*   **`params.slug`**: 파일명이 `$slug.tsx`이므로 `params` 객체에는 `slug`라는 속성으로 URL의 해당 부분 값이 들어옵니다. (예: `/categories/development` 접속 시 `params.slug`는 `"development"`)
*   **유효성 검사**: 실제 애플리케이션에서는 `params` 값에 대해 더 엄격한 유효성 검사(예: Zod 사용)를 수행하는 것이 좋습니다.
*   **데이터베이스 필터링 (`where` 조건)**: Drizzle ORM의 `where` 메서드와 조건 함수(`eq`, `gt`, `lt`, `like` 등)를 사용하여 `params`에서 얻은 값으로 데이터베이스 조회를 필터링합니다. `eq(jobs.category, categorySlug)`는 "jobs 테이블의 category 컬럼 값이 categorySlug 변수의 값과 같은" 레코드를 찾는 조건입니다.

## 3. 컴포넌트에서 URL 파라미터 접근

페이지 컴포넌트에서도 URL 파라미터 값이 필요할 때가 있습니다. 두 가지 주요 방법이 있습니다.

1.  **`loader`에서 반환받기 (권장)**: `loader` 함수에서 `params` 값을 처리하고 필요한 정보(여기서는 `categoryName`)를 가공하여 `Response.json()`으로 반환하면, 컴포넌트에서는 `useLoaderData` 훅을 통해 쉽게 사용할 수 있습니다. 데이터 로딩과 관련된 로직은 `loader`에 집중시키는 것이 좋습니다.
2.  **`useParams` 훅 사용**: Remix가 제공하는 `useParams` 훅을 사용하면 컴포넌트 내에서 직접 URL 파라미터 객체(`params`)에 접근할 수 있습니다. `loader`를 거치지 않고 파라미터 값이 필요할 때 유용합니다.

```typescript
import { useLoaderData, useParams } from '@remix-run/react';

// Loader 함수 정의 (categoryName 반환 가정)
// export async function loader({ params }: LoaderFunctionArgs) { ... return Response.json({ ..., categoryName: params.slug }); }

export default function CategoryPage() {
  // 방법 1: loader에서 반환된 데이터 사용
  const { jobList, categoryName } = useLoaderData<typeof loader>();

  // 방법 2: useParams 훅 사용 (필요시)
  const params = useParams();
  const slugFromParams = params.slug; // categoryName과 동일한 값을 가짐

  return (
    <div>
      {/* loader에서 받은 categoryName 사용 */}
      <h1>카테고리: {categoryName}</h1>

      {/* useParams로 받은 slugFromParams 사용 (결과는 동일) */}
      {/* <h2>현재 슬러그: {slugFromParams}</h2> */}

      {/* ... jobList 렌더링 ... */}
    </div>
  );
}

```

## 4. 카테고리 데이터 관리의 발전 방향 (향후 고려사항)

현재는 `jobs` 테이블 내의 `category` 문자열 컬럼을 직접 사용하여 카테고리를 구분하고 있습니다. 이는 간단한 시작에는 좋지만, 애플리케이션이 복잡해지면 다음과 같은 한계가 있을 수 있습니다.

*   **일관성 부족**: 'development', 'Development', 'dev' 등 같은 의미의 카테고리가 다른 문자열로 저장될 수 있습니다.
*   **정보 부족**: 카테고리 자체에 대한 추가 정보(예: 설명, 아이콘, 표시 순서 등)를 저장하기 어렵습니다.
*   **관리의 어려움**: 전체 카테고리 목록을 가져오거나 관리(추가/수정/삭제)하는 것이 비효율적입니다.

따라서 향후에는 **별도의 `categories` 테이블**을 만드는 것을 고려해볼 수 있습니다.

*   **`categories` 테이블 스키마 예시:**
    *   `id` (Primary Key)
    *   `slug` (Unique, URL 및 내부 식별용, 예: 'development')
    *   `name` (표시용 이름, 예: '웹 개발')
    *   `description` (선택적 설명)
*   **`jobs` 테이블 수정:**
    *   기존 `category` (varchar) 컬럼 대신 `categoryId` (integer) 컬럼을 추가하고, `categories` 테이블의 `id`를 참조하는 외래 키로 설정합니다.

이렇게 하면 카테고리를 중앙에서 관리하고, 데이터 일관성을 높이며, 각 카테고리에 더 풍부한 정보를 연결할 수 있습니다. 카테고리 페이지의 `loader`에서는 `slug`로 `categories` 테이블을 먼저 조회하여 `categoryId`를 얻고, 그 `categoryId`로 `jobs` 테이블을 필터링하게 됩니다. 