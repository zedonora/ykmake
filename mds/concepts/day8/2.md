# Day 8 - 개념 2: 서버 사이드 인증 vs 클라이언트 사이드 인증

웹 애플리케이션에서 사용자를 확인하고 권한을 부여하는 인증(Authentication)은 매우 중요한 보안 요소입니다. 인증 로직을 어디서 처리하느냐에 따라 크게 **클라이언트 사이드 인증**과 **서버 사이드 인증**으로 나눌 수 있으며, Remix와 같은 풀스택 프레임워크에서는 **서버 사이드 인증이 필수적**입니다.

## 1. 클라이언트 사이드 인증 (Client-Side Authentication)

*   **동작 방식**: 사용자가 입력한 정보(이메일, 비밀번호 등)를 클라이언트(웹 브라우저)에서 직접 외부 인증 서비스(예: Firebase Auth, Auth0 Universal Login)로 보내 인증을 시도하고, 성공하면 받은 토큰(Token)을 브라우저 저장소(localStorage, sessionStorage)에 저장합니다. 이후 API 요청 시 이 토큰을 헤더에 포함하여 서버에 전송하면, 서버는 토큰의 유효성을 검증하여 사용자를 식별합니다.
*   **장점**:
    *   서버 부담 감소: 인증 처리 자체를 외부 서비스나 클라이언트가 담당합니다.
    *   분리된 구조: 프론트엔드와 백엔드가 완전히 분리된 경우(예: SPA + 별도 API 서버) 자연스럽게 사용될 수 있습니다.
*   **단점**:
    *   **보안 취약성**: 토큰이 브라우저에 저장되므로 XSS(Cross-Site Scripting) 공격에 의해 탈취될 위험이 높습니다. 탈취된 토큰은 공격자가 정상 사용자인 것처럼 위장하는 데 사용될 수 있습니다.
    *   **토큰 관리의 복잡성**: 토큰 갱신(refresh), 만료 처리, 안전한 저장 및 전송 로직을 클라이언트에서 직접 구현해야 합니다.
    *   서버 렌더링 제한: 서버 렌더링 시 사용자의 인증 상태를 확인하기 어렵거나 추가적인 통신이 필요할 수 있습니다.

## 2. 서버 사이드 인증 (Server-Side Authentication) - Remix의 기본 방식

*   **동작 방식**: 사용자가 입력한 정보를 Remix `<Form>`을 통해 서버의 `action` 함수로 직접 전송합니다. 서버는 받은 정보를 바탕으로 데이터베이스에서 사용자 정보를 확인하고 비밀번호를 비교합니다. 인증에 성공하면, 서버는 사용자 정보를 식별할 수 있는 **세션(Session)** 데이터를 생성하고, 이 세션 ID가 포함된 **쿠키(Cookie)** 를 클라이언트(브라우저)에게 응답 헤더(`Set-Cookie`)를 통해 전달합니다. 브라우저는 이후 요청 시 자동으로 해당 쿠키를 요청 헤더에 포함하여 서버로 보냅니다. 서버는 받은 쿠키의 세션 ID를 통해 사용자를 식별하고 인증 상태를 확인합니다.
*   **장점**:
    *   **보안 강화**:
        *   **민감 정보 서버 보관**: 사용자 비밀번호와 같은 민감한 정보는 서버에서만 처리되고 클라이언트로 전송되지 않습니다.
        *   **세션 데이터 서버 관리**: 실제 사용자 식별 정보는 서버 측 세션 저장소(메모리, 데이터베이스, Redis 등)에 안전하게 보관됩니다. 클라이언트에는 의미 없는 세션 ID만 쿠키로 전달됩니다.
        *   **HttpOnly 쿠키**: 세션 ID가 담긴 쿠키에 `HttpOnly` 플래그를 설정하면 JavaScript를 통한 접근을 차단하여 XSS 공격으로 인한 세션 탈취 위험을 크게 줄일 수 있습니다. `Secure` 플래그(HTTPS에서만 전송), `SameSite` 플래그(CSRF 방어) 등 추가적인 보안 설정도 가능합니다.
    *   **중앙화된 로직**: 인증 및 세션 관리 로직이 서버(`*.server.ts` 파일)에 집중되어 관리가 용이합니다.
    *   **서버 렌더링과의 통합**: `loader` 함수에서 요청 쿠키를 확인하여 서버 렌더링 시 사용자의 인증 상태를 쉽게 파악하고 이에 따른 데이터 로딩이나 UI 렌더링이 가능합니다.
*   **단점**:
    *   서버 부하 증가: 인증 및 세션 관리 로직을 서버가 직접 처리하므로 클라이언트 사이드 방식보다 서버 부하가 다소 발생할 수 있습니다. (하지만 현대 웹 프레임워크와 인프라에서는 일반적으로 큰 문제가 되지 않습니다.)

## 3. Remix에서의 서버 사이드 인증 구현 요소

`jobs/day8/2.md`에서 생성한 파일 및 설치한 라이브러리는 Remix에서 서버 사이드 인증을 구현하는 데 핵심적인 역할을 합니다.

*   **`app/services/auth.server.ts`**: 실제 인증 로직을 담당합니다. `remix-auth` 라이브러리와 같은 도구를 사용하여 다양한 인증 전략(이메일/비밀번호, 소셜 로그인 등)을 구현할 수 있습니다. 사용자 검증, 세션 생성 등의 핵심 기능이 위치합니다.
*   **`app/services/session.server.ts`**: 세션 데이터를 저장하고 관리하는 방법을 정의합니다. Remix는 다양한 세션 저장소(쿠키 기반, 파일, 데이터베이스 등)를 지원하며, 여기서 어떤 저장소를 사용할지, 세션 비밀 키는 무엇인지 등을 설정합니다.
*   **`app/services/users.server.ts`**: 사용자 관련 데이터베이스 작업을 처리합니다. 회원가입 시 사용자 정보를 DB에 저장하고, 로그인 시 이메일로 사용자를 조회하는 등의 기능을 구현합니다. 특히, **비밀번호 해싱**(예: `bcryptjs` 사용) 로직이 여기에 포함되어야 합니다. 비밀번호는 절대 평문으로 저장해서는 안 됩니다.
*   **`bcryptjs`**: 안전한 비밀번호 해싱을 위한 라이브러리입니다. 사용자가 입력한 비밀번호를 복호화 불가능한 해시 값으로 변환하여 데이터베이스에 저장하고, 로그인 시에는 입력된 비밀번호를 동일한 방식으로 해싱하여 저장된 해시 값과 비교합니다.
*   **`remix-auth` / `remix-auth-form`**: Remix 애플리케이션에서 인증 흐름을 쉽게 구현할 수 있도록 도와주는 라이브러리입니다. `FormStrategy`는 이메일/비밀번호 기반 인증을 구현하는 데 사용됩니다. `authenticator` 객체를 통해 인증 상태 확인(`isAuthenticated`), 로그인(`authenticate`), 로그아웃(`logout`) 등의 기능을 편리하게 사용할 수 있습니다.
*   **`.server.ts` 접미사**: 이 파일들이 서버 전용임을 명시하여, 민감한 로직이나 비밀 키가 클라이언트 번들에 포함되는 것을 방지합니다. Remix 빌드 시스템이 이를 인지하고 처리해줍니다.

**결론적으로, Remix 애플리케이션에서는 보안과 서버 렌더링 통합의 이점을 위해 반드시 서버 사이드 인증 방식을 사용해야 합니다.** 클라이언트에서 인증 로직을 직접 처리하거나 민감한 정보를 저장하는 것은 심각한 보안 위험을 초래할 수 있습니다. 