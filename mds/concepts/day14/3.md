# Day 14 - 개념 3: 프로필 페이지에서의 데이터 집계 및 표시 전략

`jobs/day14/3.md`에서는 사용자 프로필 페이지에 해당 사용자의 활동 내역(작성한 글, 댓글)을 모아서 보여주는 기능을 구현합니다. 이는 사용자에게 자신의 활동 기록을 확인하거나 다른 사용자의 활동을 파악하는 데 유용한 정보를 제공합니다. 이 과정에서 **데이터 집계**, **효율적인 데이터 조회**, **표시 전략**에 대한 개념을 이해하는 것이 중요합니다.

## 1. 프로필 페이지에서의 데이터 집계 (Data Aggregation)

*   **목적**: 사용자 프로필 페이지는 단순히 사용자 정보만 보여주는 것을 넘어, 해당 사용자와 관련된 다양한 데이터를 한 곳에 모아 보여주는 **대시보드** 역할을 하는 경우가 많습니다.
    *   사용자가 생성한 콘텐츠 (게시글, 댓글, 리뷰, 상품 등)
    *   사용자의 활동 내역 (좋아요 표시, 북마크 등)
    *   (소셜 기능이 있다면) 팔로워/팔로잉 정보 등
*   **구현**: Remix의 `loader` 함수에서 해당 사용자의 ID (`userId`)를 기준으로 관련된 여러 테이블(`profiles`, `posts`, `replies` 등)에서 필요한 데이터를 조회하여 한 번에 클라이언트로 전달합니다.

## 2. 효율적인 데이터 조회: 중첩된 Select (JOIN) 활용

프로필 페이지에서 여러 종류의 데이터를 가져올 때, 각 데이터 항목에 필요한 관련 정보(예: 댓글 목록을 가져올 때 각 댓글이 달린 게시글의 제목)를 효율적으로 가져오는 것이 중요합니다.

*   **N+1 문제 회피**: 만약 댓글 목록을 먼저 가져온 후, 각 댓글마다 해당 게시글 정보를 얻기 위해 별도의 쿼리를 실행한다면, 댓글 수(N)만큼 추가 쿼리가 발생하여 성능이 크게 저하됩니다 (N+1 문제).
*   **Supabase의 중첩 Select (JOIN)**: Supabase 클라이언트는 외래 키 관계가 설정된 테이블 간의 데이터를 한 번의 쿼리로 효율적으로 가져올 수 있는 중첩된 `select` 구문을 제공합니다.
    ```javascript
    // replies 테이블 조회 시, 외래 키로 연결된 posts 테이블의 id와 title을 함께 가져옴
    const { data: replies } = await supabase
      .from("replies")
      .select(`
        id,
        content,
        created_at,
        posts ( id, title )  // posts 테이블 정보 중첩 조회
      `)
      .eq("user_id", userId);
    ```
*   **이점**: 데이터베이스 왕복 횟수를 줄여 응답 속도를 개선하고 서버 부하를 낮춥니다. 프로필 페이지처럼 여러 연관 데이터를 한 번에 로드해야 하는 경우 특히 유용합니다.
*   **주의**: JOIN하는 테이블(`posts`)에도 적절한 RLS 읽기 정책이 설정되어 있어야 합니다.

## 3. 데이터 표시 전략 및 UI 구성

프로필 페이지에 집계된 다양한 데이터를 사용자에게 효과적으로 보여주기 위한 UI 전략이 필요합니다.

*   **탭 (Tabs)**: 가장 일반적인 방법 중 하나입니다. 서로 다른 종류의 콘텐츠 목록(예: "작성한 글", "작성한 댓글", "좋아요한 글")을 별도의 탭으로 구분하여 보여줍니다. 사용자는 원하는 정보만 선택적으로 볼 수 있어 복잡도를 낮춥니다. Shadcn UI의 `Tabs` 컴포넌트를 활용하면 쉽게 구현할 수 있습니다. (`jobs/day14/3.md` 예시)
*   **콘텐츠 요약**: 각 탭의 트리거(버튼)에 해당 콘텐츠의 개수(예: "작성한 글 (15)")를 함께 표시하면 사용자가 각 섹션의 규모를 미리 파악하는 데 도움이 됩니다. `loader`에서 각 목록의 개수(`count`)를 함께 조회하거나, 클라이언트에서 `list.length`를 사용합니다.
*   **목록 아이템 디자인**: 각 목록의 항목(게시글, 댓글)을 명확하고 간결하게 표시해야 합니다.
    *   **게시글**: 제목, 작성일, (선택적) 요약 또는 썸네일 이미지
    *   **댓글**: 댓글 내용 (길면 일부만 표시), 작성일, **원본 콘텐츠 정보 및 링크**(예: "게시글 'Remix란 무엇인가?'에 남긴 댓글")
*   **긴 목록 처리**: 사용자의 활동 내역이 많아지면 한 페이지에 모든 목록을 표시하기 어려워집니다.
    *   **페이지네이션 (Pagination)**: 목록을 여러 페이지로 나누어 보여주는 전통적인 방식입니다. `loader`에서 페이지 번호와 페이지당 항목 수를 기반으로 `range()` 메서드를 사용하여 데이터를 가져오고, 페이지 이동 UI를 구현합니다.
    *   **무한 스크롤 (Infinite Scrolling) / 더 보기 버튼**: 스크롤을 내리거나 '더 보기' 버튼을 클릭하면 다음 목록 데이터를 비동기적으로 로드하여 추가하는 방식입니다. Remix의 `useFetcher()` 훅을 사용하여 구현할 수 있습니다. `loader`는 페이지 번호(또는 커서)를 인자로 받아 해당 데이터를 반환하도록 수정해야 합니다.

## 4. 성능 고려사항 및 최적화

`loader` 함수에서 여러 테이블로부터 다수의 데이터를 조회하는 것은 페이지 로딩 성능에 영향을 미칠 수 있습니다.

*   **데이터 양 제한**: 초기 로드 시에는 각 목록의 항목 수를 `limit()`을 사용하여 적절히 제한합니다. (예: 10~20개)
*   **필요한 컬럼만 선택**: `select()` 구문에서 반드시 필요한 컬럼만 명시적으로 지정하여 전송되는 데이터 양을 줄입니다.
*   **데이터베이스 인덱스**: `posts` 테이블과 `replies` 테이블의 `user_id` 컬럼에 인덱스를 생성하면 해당 사용자의 데이터를 조회하는 속도를 크게 향상시킬 수 있습니다.
    ```sql
    CREATE INDEX idx_posts_user_id ON public.posts(user_id);
    CREATE INDEX idx_replies_user_id ON public.replies(user_id);
    ```
*   **비동기 처리**: `loader` 내에서 여러 데이터 조회(`profile`, `posts`, `replies`)는 `Promise.all()`을 사용하여 병렬로 실행하면 총 로딩 시간을 단축할 수 있습니다. (단, 서로 의존성이 없을 경우)

## 요약

사용자 프로필 페이지는 다양한 사용자 관련 데이터를 집계하여 보여주는 중요한 역할을 합니다. Remix의 `loader`와 Supabase의 중첩 `select` (JOIN) 기능을 활용하여 관련 데이터를 효율적으로 가져올 수 있습니다. `Tabs` 컴포넌트는 여러 종류의 데이터를 정리하여 보여주는 효과적인 UI 전략이며, 긴 목록은 페이지네이션이나 무한 스크롤 방식으로 처리해야 합니다. 초기 로딩 성능을 위해 데이터 양을 제한하고 필요한 컬럼만 선택하며, 데이터베이스 인덱스를 활용하는 것이 중요합니다. 