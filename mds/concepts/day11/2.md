# Day 11 - 개념 2: Remix 라우트, Loader, Action 및 데이터 유효성 검사

이 문서에서는 Day 11의 두 번째 작업인 "제품 등록 페이지 UI 및 Action 구현"과 관련된 핵심 Remix 개념(라우트, Loader, Action)과 데이터 유효성 검사의 중요성 및 구현 방법을 설명합니다.

## 1. Remix 라우트 (Routes)

*   **파일 시스템 기반 라우팅**: Remix는 파일 시스템 구조를 기반으로 웹 애플리케이션의 라우트를 정의합니다. `app/routes/` 디렉토리 안에 파일을 생성하면 해당 파일 경로에 따라 URL 라우트가 자동으로 매핑됩니다.
    *   예시: `app/routes/products.new.tsx` 파일은 웹 브라우저에서 `/products/new` URL에 접근했을 때 렌더링될 페이지 컴포넌트와 관련 로직을 정의합니다.
*   **중첩 라우트 (Nested Routes)**: Remix는 중첩 레이아웃과 라우트를 지원하여 UI와 데이터 로딩 로직을 효과적으로 구성할 수 있습니다. 부모 라우트의 레이아웃과 데이터를 자식 라우트가 상속받아 사용할 수 있습니다. (이번 작업에서는 직접적인 중첩 라우트 예시는 없지만, 일반적인 Remix의 강력한 기능입니다.)

## 2. Loader 함수

*   **목적**: `loader` 함수는 서버 측에서 특정 라우트가 렌더링되기 **전에** 실행되는 함수입니다. 주된 역할은 해당 페이지 컴포넌트가 렌더링하는 데 필요한 데이터를 미리 로드하는 것입니다. 또한, 접근 제어 로직(예: 로그인 상태 확인)을 구현하는 데에도 사용됩니다.
*   **실행 시점**: 사용자가 해당 URL로 이동할 때마다 서버에서 실행됩니다.
*   **데이터 전달**: `loader` 함수는 `json()` 유틸리티 함수를 사용하여 데이터를 직렬화하고, 이를 HTTP 응답으로 클라이언트에 전달합니다. 클라이언트 측의 페이지 컴포넌트에서는 `useLoaderData()` 훅을 사용하여 이 데이터를 받아올 수 있습니다.
*   **리디렉션 및 에러 처리**: `loader` 함수 내에서 특정 조건(예: 로그인되지 않은 사용자)에 따라 다른 페이지로 `redirect()` 시키거나, 에러 응답(`throw new Response(...)`)을 반환할 수 있습니다.
*   **예시 (`products.new.tsx`의 `loader`)**:
    *   `createSupabaseServerClient`를 사용해 요청 헤더의 쿠키를 기반으로 Supabase 세션을 확인합니다.
    *   세션이 없으면 로그인 페이지(`/auth/login`)로 리디렉션시켜, 로그인하지 않은 사용자의 페이지 접근을 차단합니다.
    *   세션이 있으면 `{ ok: true }`와 같은 간단한 데이터를 반환하고 페이지 렌더링을 허용합니다. (실제 데이터 로딩이 필요 없는 경우에도 접근 제어를 위해 사용될 수 있습니다.)

## 3. Action 함수

*   **목적**: `action` 함수는 주로 HTML `<form>` 제출과 같은 데이터 변경 요청(HTTP POST, PUT, PATCH, DELETE 등)을 처리하기 위해 서버 측에서 실행되는 함수입니다. 사용자의 입력 데이터를 받아 처리하고, 데이터베이스를 업데이트하는 등의 작업을 수행합니다.
*   **실행 시점**: 해당 라우트에 `method="post"` (또는 다른 데이터 변경 메소드) 속성을 가진 `<Form>`이 제출될 때 서버에서 실행됩니다.
*   **데이터 처리**: `request.formData()`를 사용하여 폼 데이터를 추출합니다.
*   **데이터베이스 상호작용**: 추출하고 유효성을 검사한 데이터를 사용하여 데이터베이스 작업(예: `supabase.from('products').insert(...)`)을 수행합니다.
*   **응답**:
    *   **성공**: 작업 성공 시 다른 페이지로 `redirect()` 시키거나, 성공 메시지를 담은 `json()` 응답을 반환할 수 있습니다.
    *   **실패 (유효성 검사 등)**: 데이터 유효성 검사 실패 시, 오류 정보를 담은 `json()` 응답을 `status: 400` (Bad Request)과 함께 반환합니다. 클라이언트에서는 `useActionData()` 훅으로 이 데이터를 받아 사용자에게 오류를 표시합니다.
    *   **서버 오류**: 데이터베이스 오류 등 예상치 못한 서버 에러 발생 시, 일반적인 오류 메시지를 담은 `json()` 응답을 `status: 500` (Internal Server Error)과 함께 반환합니다.
*   **예시 (`products.new.tsx`의 `action`)**:
    *   세션 유효성을 다시 한번 확인합니다.
    *   폼 데이터를 받아 Zod 스키마(`productSchema`)를 사용하여 유효성을 검사합니다.
    *   유효성 검사 실패 시 오류 객체를 JSON으로 반환합니다.
    *   유효성 검사 통과 시, `user_id`와 함께 제품 데이터를 Supabase에 `insert`합니다.
    *   `insert` 실패 시 오류를 JSON으로 반환합니다.
    *   `insert` 성공 시 홈페이지(`/`)로 리디렉션합니다.

## 4. 데이터 유효성 검사 (Data Validation)

*   **중요성**: 사용자 입력 데이터의 정확성과 안전성을 보장하기 위해 필수적입니다. 악의적인 입력을 방지하고, 애플리케이션 오류를 줄이며, 데이터베이스 무결성을 유지하는 데 중요한 역할을 합니다.
*   **구현 위치**:
    *   **클라이언트 측 (Client-Side)**: 사용자 경험(UX)을 향상시킵니다. 폼 제출 전에 즉각적인 피드백을 제공하여 사용자가 오류를 빠르게 수정할 수 있도록 돕습니다. (예: JavaScript를 사용한 실시간 검사, HTML5 내장 검증 기능, `react-hook-form` 같은 라이브러리 활용) **하지만 클라이언트 측 검증만으로는 충분하지 않습니다.**
    *   **서버 측 (Server-Side)**: **보안과 데이터 무결성을 위해 반드시 필요합니다.** 클라이언트 측 검증은 사용자가 쉽게 우회할 수 있으므로, 서버의 `action` 또는 API 엔드포인트에서 데이터를 처리하기 전에 항상 유효성을 검사해야 합니다.
*   **라이브러리 활용 (Zod)**:
    *   `zod`는 TypeScript 우선 스키마 선언 및 유효성 검사 라이브러리입니다.
    *   간결하고 강력한 API를 제공하여 데이터의 형태(타입, 필수 여부, 최소/최대 길이, 패턴 등)를 정의하고 검증할 수 있습니다.
    *   `productSchema.safeParse(rawData)`와 같이 사용하여 유효성 검사 결과를 안전하게 얻을 수 있습니다. 성공 시 `{ success: true, data: ... }`, 실패 시 `{ success: false, error: ... }` 객체를 반환합니다.
    *   실패 시 `error.flatten().fieldErrors`를 사용하면 필드별 오류 메시지를 쉽게 추출하여 클라이언트에 전달할 수 있습니다.
*   **처리 흐름**:
    1.  클라이언트: (선택 사항) 폼 입력 시 실시간 또는 제출 시 유효성 검사 및 피드백.
    2.  클라이언트: 폼 제출 (`<Form method="post">`).
    3.  서버 (`action`): 폼 데이터 수신 (`request.formData()`).
    4.  서버 (`action`): **Zod 스키마를 사용한 서버 측 유효성 검사**.
    5.  서버 (`action`):
        *   유효성 검사 실패 시: 오류 정보와 함께 `json({...}, { status: 400 })` 반환.
        *   유효성 검사 성공 시: 데이터베이스 작업 수행 및 성공/실패에 따른 `redirect` 또는 `json` 응답 반환.
    6.  클라이언트: `useActionData` 훅을 사용하여 `action` 함수의 반환값(오류 또는 성공 메시지)을 받아 UI에 표시.

## 요약

Remix의 `loader`와 `action` 함수는 서버 측 로직을 각 라우트 파일 내에서 효과적으로 구성할 수 있게 해줍니다. `loader`는 데이터 로딩과 접근 제어를 담당하고, `action`은 데이터 변경 요청 처리를 담당합니다. 견고한 애플리케이션 구축을 위해서는 클라이언트 측과 **특히 서버 측**에서 Zod와 같은 라이브러리를 활용한 철저한 데이터 유효성 검사가 필수적입니다. 