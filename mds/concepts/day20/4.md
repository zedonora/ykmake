# Day 20 - 개념 4: 채팅 앱에서의 파일/이미지 전송: 아키텍처 및 구현 개념

텍스트 기반 채팅을 넘어 파일이나 이미지를 공유하는 기능은 현대 채팅 애플리케이션의 필수 요소입니다. 이 기능을 구현하기 위해서는 파일 저장소(Storage), 데이터베이스, 클라이언트 간의 상호작용을 이해하고 적절한 아키텍처를 설계해야 합니다.

## 1. 파일 전송 아키텍처 개요

일반적인 클라이언트-서버 기반 파일 전송 아키텍처는 다음과 같은 흐름을 따릅니다:

1.  **클라이언트**: 사용자가 파일을 선택합니다.
2.  **클라이언트**: (선택적) 파일 유효성 검사(크기, 타입) 및 미리보기를 수행합니다.
3.  **클라이언트**: 파일을 **파일 저장소(Storage)** 로 직접 업로드합니다. 서버를 거치지 않고 클라이언트에서 직접 Storage API를 호출하는 것이 일반적입니다(보안 정책 필요).
4.  **Storage**: 파일 저장을 완료하고, 파일에 접근할 수 있는 고유한 경로 또는 식별자(예: `path`)를 클라이언트에 반환합니다.
5.  **클라이언트**: Storage로부터 받은 파일 정보(`path`, 파일 이름, 타입, 크기 등)와 함께 채팅 메시지 정보를 **애플리케이션 서버(또는 DB 직접 호출)** 로 전송합니다.
6.  **서버/DB**: 전달받은 메시지 내용과 파일 참조 정보(Storage 경로 또는 URL)를 **데이터베이스(`messages` 또는 `attachments` 테이블)** 에 저장합니다.
7.  **다른 클라이언트**: 새 메시지(파일 정보 포함)를 실시간으로 수신하거나, 채팅방 로드 시 메시지 목록을 조회합니다.
8.  **클라이언트**: 메시지 데이터를 기반으로 UI를 렌더링합니다. 파일 메시지의 경우, 저장된 파일 URL을 사용하여 이미지/파일 링크 등을 표시합니다.

이 아키텍처는 서버의 부하를 줄이고(파일 전송 직접 처리 안 함) 확장성을 높이는 데 유리합니다.

## 2. Supabase Storage 활용

Supabase Storage는 파일 저장을 위한 편리하고 안전한 솔루션을 제공합니다.

*   **버킷(Buckets)**: 파일을 그룹화하는 컨테이너입니다. 용도별(예: `avatars`, `chat_attachments`)로 버킷을 분리하여 관리하는 것이 좋습니다.
*   **Public vs. Private 버킷**:
    *   **Public**: 버킷 내 파일은 누구나 URL을 통해 직접 접근할 수 있습니다. 공개 프로필 이미지 등에 적합합니다.
    *   **Private**: 기본적으로 접근이 차단되며, **Storage RLS 정책**을 통해서만 접근 권한을 부여받은 사용자가 파일을 다운로드/업로드할 수 있습니다. 채팅 첨부파일과 같이 민감하거나 접근 제어가 필요한 파일에 적합합니다.
*   **Storage RLS (Row Level Security)**: 데이터베이스 RLS와 유사하게, SQL을 사용하여 파일 객체(`storage.objects`)에 대한 접근(SELECT, INSERT, UPDATE, DELETE) 규칙을 정의합니다. 이를 통해 "채팅방 참여자만 해당 방 폴더의 파일을 보거나 업로드할 수 있다"와 같은 세분화된 제어가 가능합니다.
    *   정책 정의 시 `bucket_id`, `storage.foldername(name)`, `auth.uid()` 등의 정보를 활용하여 조건을 설정합니다.
*   **파일 경로/이름**: Storage 내에서 파일을 고유하게 식별하는 경로와 이름 규칙을 정하는 것이 중요합니다. 충돌을 방지하고 RLS 정책 적용을 용이하게 하기 위해 `roomId`, `userId`, UUID 등을 조합하여 사용하는 것이 일반적입니다.

## 3. 데이터베이스 스키마 디자인: 메시지 테이블 확장 vs. 첨부파일 테이블 분리

파일 정보를 데이터베이스에 어떻게 저장할지는 애플리케이션 요구사항에 따라 결정됩니다.

*   **`messages` 테이블 확장 (`message_type`, `file_url` 등 추가)**:
    *   **장점**: 구조가 단순하고, 메시지 조회 시 파일 정보도 함께 가져오기 쉽습니다.
    *   **단점**: 메시지 하나당 첨부파일 하나만 가능하며, `messages` 테이블이 비대해질 수 있습니다. 텍스트 메시지에는 불필요한 파일 관련 컬럼이 NULL로 채워집니다.
*   **별도 `attachments` 테이블 분리 (`message_id` 외래 키)**:
    *   **장점**: 메시지 하나에 여러 첨부파일을 연결할 수 있습니다. 첨부파일 관련 로직(예: 특정 타입 파일만 검색)을 분리하기 용이합니다. `messages` 테이블 구조를 깔끔하게 유지할 수 있습니다.
    *   **단점**: 파일 정보를 가져오려면 추가적인 JOIN이 필요할 수 있습니다. (RPC/View로 해결 가능)
*   **선택**: 기능 요구사항(메시지당 파일 개수), 데이터 모델의 복잡성, 향후 확장성 등을 고려하여 적합한 방식을 선택합니다.

## 4. 파일 URL 관리: Public URL vs. Signed URL

Storage에 저장된 파일에 접근하기 위한 URL을 관리하는 방법입니다.

*   **Public URL**: Public 버킷의 파일에 대한 직접적인 URL입니다. 누구나 접근 가능합니다.
*   **Signed URL (서명된 URL)**: Private 버킷의 파일에 대해 **일정 시간 동안만 유효한** 접근 토큰이 포함된 URL입니다. `supabase.storage.from(...).createSignedUrl(path, expiresInSeconds)` 함수를 사용하여 생성합니다.
    *   **장점**: Private 파일에 대해 임시적인 접근 권한을 안전하게 부여할 수 있습니다. (예: 채팅 참여자에게만 이미지 표시)
    *   **단점**: URL 유효 기간 관리가 필요하며, 클라이언트에서 필요할 때마다 새로 생성해야 할 수 있습니다. (캐싱 전략 필요)
*   **직접 접근 (RLS 기반)**: 클라이언트가 Supabase SDK를 사용하여 Storage RLS 정책 검사를 거쳐 직접 파일을 다운로드(`supabase.storage.from(...).download(path)`)하는 방식도 가능합니다. 이 경우 URL을 외부에 노출할 필요가 없습니다.
*   **선택**: Private 버킷을 사용한다면, 보안과 편의성을 고려하여 Signed URL 방식 또는 RLS 기반 직접 접근 방식을 선택합니다.

## 5. 클라이언트 측 파일 처리

*   **파일 입력**: HTML `<input type="file">` 요소를 사용하고, `accept` 속성으로 허용할 파일 타입을 제한할 수 있습니다.
*   **유효성 검사**: 클라이언트에서 파일 크기, 파일 타입을 미리 검사하여 불필요한 업로드 시도를 막고 사용자 경험을 개선합니다.
*   **업로드 API 호출**: Supabase JavaScript 라이브러리의 `supabase.storage.from(...).upload()` 함수를 사용합니다. 비동기 처리 및 오류 처리가 중요합니다.
*   **진행률**: 대용량 파일의 경우, `upload()` 함수의 이벤트 리스너나 관련 라이브러리를 사용하여 업로드 진행률을 사용자에게 보여주는 것이 좋습니다.

## 6. 채팅 UI 렌더링

메시지 목록을 표시할 때, 메시지 타입(`message_type`)에 따라 다르게 렌더링해야 합니다.

*   **이미지**: `<img>` 태그의 `src` 속성에 파일 URL(Public 또는 Signed)을 지정하여 이미지를 표시합니다. 클릭 시 확대 보기 기능 등을 추가할 수 있습니다.
*   **파일**: 파일 아이콘, 파일 이름, 크기 정보를 표시하고, 파일 URL로 연결되는 다운로드 링크(`<a>` 태그, `download` 속성 사용 가능)를 제공합니다.
*   **텍스트**: 기존과 동일하게 텍스트 내용을 표시합니다.

## 결론

채팅 앱에 파일/이미지 전송 기능을 추가하는 것은 단순히 파일을 저장하는 것을 넘어, 안전한 저장소 설정(Supabase Storage), 효율적인 데이터베이스 스키마 설계, 보안적인 파일 접근(RLS, Signed URL), 그리고 사용자 친화적인 클라이언트 처리 및 UI 렌더링까지 고려해야 하는 복합적인 작업입니다. 각 단계별 개념을 이해하고 적절한 기술을 선택하여 구현하는 것이 중요합니다. 