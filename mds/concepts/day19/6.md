# Day 19 - 개념 6: Realtime 앱의 견고성 확보: 오류 처리 및 UX 개선

실시간 애플리케이션은 데이터가 끊임없이 흐르고 상태가 동적으로 변하기 때문에, 예기치 않은 오류나 네트워크 불안정성에 대비하는 것이 매우 중요합니다. 견고한 오류 처리와 세심한 UI/UX 개선은 사용자 신뢰도를 높이고 애플리케이션의 완성도를 결정짓는 핵심 요소입니다.

## 1. Realtime 연결 및 구독 오류 처리의 중요성

실시간 기능의 핵심은 서버와의 지속적인 연결입니다. 하지만 네트워크는 불안정할 수 있으며, 서버 측 문제나 클라이언트 환경 제약으로 인해 연결 또는 특정 채널 구독에 실패할 수 있습니다.

*   **구독 상태 (`channel.subscribe()` 콜백)**:
    *   `SUBSCRIBED`: 성공적으로 채널에 연결되어 이벤트를 수신할 준비가 된 상태. 이 시점에 초기 상태 전송(`track`) 등을 수행합니다.
    *   `CHANNEL_ERROR`: 채널 접근 권한 부족(RLS 정책 등), 서버 내부 오류 등으로 구독이 거부된 상태. 사용자에게 명확한 원인(가능하다면)과 함께 실패를 알리고, 문제 해결 가이드(예: 재로그인 유도)를 제공해야 할 수 있습니다.
    *   `TIMED_OUT`: 설정된 시간 내에 구독 응답을 받지 못한 상태. 일시적인 네트워크 문제일 가능성이 높으므로, 지수 백오프(Exponential Backoff) 전략을 사용한 자동 재시도를 구현하는 것이 효과적입니다. 사용자에게는 연결 재시도 중임을 알리는 것이 좋습니다.
*   **일반 오류 (`channel.onError()` 리스너)**:
    *   구독 이후 발생하는 예기치 않은 오류(네트워크 끊김, 서버 재시작 등)를 감지합니다.
    *   오류 발생 시, 사용자에게 연결이 불안정함을 알리고, 필요한 경우 애플리케이션 상태를 안전하게 관리(예: 메시지 전송 버튼 비활성화)하며 재연결 로직을 실행합니다.
*   **사용자 피드백**: 오류 발생 시 사용자에게 "현재 실시간 연결에 문제가 있습니다. 잠시 후 다시 시도합니다." 와 같이 명확하고 간결한 메시지를 제공하여 불안감을 해소해야 합니다. (Toast, Snackbar 등 활용)

## 2. Optimistic UI: 장점, 단점, 그리고 실패 처리

Optimistic UI는 사용자가 작업을 수행했을 때(예: 메시지 전송), 서버 응답을 기다리지 않고 즉시 UI에 변경 사항을 반영하는 기법입니다. 이는 사용자에게 빠른 반응성을 제공하여 경험을 향상시킵니다.

*   **장점**: 즉각적인 피드백으로 사용자는 자신의 행동이 처리되었다고 느끼며, 네트워크 지연으로 인한 답답함을 줄일 수 있습니다.
*   **단점**: 서버 처리 결과와 클라이언트의 예측이 다를 수 있습니다.
    *   **중복 표시**: Optimistic 업데이트 후 실제 데이터(예: Broadcast 이벤트)가 도착했을 때, 동일한 내용이 중복으로 표시될 수 있습니다. 이를 방지하기 위해 고유 ID(임시 ID 또는 실제 ID)를 사용하여 중복 여부를 확인하고 처리해야 합니다.
    *   **전송 실패**: 서버에서 요청 처리에 실패(유효성 검사 오류, DB 오류 등)하면, UI는 이미 성공한 것처럼 보이지만 실제 데이터는 반영되지 않은 상태 불일치가 발생합니다.
*   **실패 처리 (Rollback)**:
    *   서버로부터 실패 응답을 받으면, Optimistic하게 변경했던 UI 상태를 원래대로 되돌려야 합니다 (Rollback).
    *   예: 전송했던 메시지를 목록에서 제거하거나, 실패 상태임을 명확히 표시(흐리게 처리, 느낌표 아이콘, 재전송 버튼 등)하고 사용자에게 오류 내용을 알려줍니다.
    *   상태 관리 라이브러리(Zustand, Redux 등)나 `useReducer` 등을 사용하면 이전 상태를 관리하고 롤백하는 로직을 더 체계적으로 구현할 수 있습니다.

## 3. Presence 및 상태 동기화: 신뢰도 높이기

Presence(온라인 상태, 타이핑 상태 등) 정보는 네트워크 지연이나 예기치 않은 연결 끊김으로 인해 부정확해질 수 있습니다.

*   **초기 상태 및 하트비트(Heartbeat)**: 채널 구독 성공 시 자신의 현재 상태(`online_at`, `is_typing: false`)를 `track()`으로 즉시 알리는 것이 중요합니다. 또한, 주기적으로 자신의 상태를 `track()`하여 ("나 아직 온라인 상태야") 네트워크 문제로 인해 `leave` 이벤트가 잘못 발생하더라도 상태를 복구할 수 있도록 합니다. (Supabase Presence는 내부적으로 하트비트 메커니즘을 사용합니다.)
*   **상태 동기화 (`sync` 이벤트)**: `presence`의 `sync` 이벤트는 현재 채널에 있는 모든 참여자의 최신 상태 정보를 한 번에 받아오는 메커니즘입니다. 이 이벤트를 활용하여 주기적으로 클라이언트의 로컬 상태와 서버의 실제 상태를 동기화하면 상태 불일치 문제를 줄일 수 있습니다.
*   **타이핑 상태 타임아웃**: 사용자가 타이핑을 멈췄음에도 네트워크 문제로 `is_typing: false` 이벤트가 전달되지 않으면, 상대방 화면에는 계속 입력 중으로 보일 수 있습니다. 이를 방지하기 위해, `is_typing: true` 이벤트를 받은 후 일정 시간(예: 3~5초) 동안 추가적인 타이핑 이벤트나 메시지 수신이 없으면 클라이언트 자체적으로 타이핑 상태를 `false`로 간주하는 타임아웃 로직을 구현하는 것이 좋습니다.

## 4. 사용자 경험(UX) 개선 패턴

오류 처리 외에도 사용자가 애플리케이션을 더 원활하게 사용할 수 있도록 돕는 UI/UX 패턴들이 있습니다.

*   **로딩 상태 표시**: 데이터(메시지 목록 등)를 불러오는 동안에는 빈 화면 대신 스켈레톤 UI(내용의 윤곽선을 먼저 보여주는 방식)나 로딩 인디케이터(스피너 등)를 표시하여 사용자가 시스템이 작동 중임을 인지하고 기다릴 수 있도록 합니다.
*   **명확한 오류 피드백**: 오류 발생 시, 단순히 "오류 발생"이라고 알리기보다는 무엇이 잘못되었고 사용자가 무엇을 해야 하는지(또는 시스템이 무엇을 할 것인지) 명확하게 안내하는 것이 중요합니다. Toast 메시지나 인라인 오류 메시지를 활용하여 간결하고 눈에 띄게 전달합니다.
*   **일관성 있는 인터페이스**: 로딩, 오류, 성공 등 다양한 상태에 대한 시각적 피드백을 애플리케이션 전반에 걸쳐 일관성 있게 디자인하면 사용자가 인터페이스를 더 쉽게 학습하고 예측할 수 있습니다.

## 결론

실시간 애플리케이션 개발은 단순히 기능을 구현하는 것을 넘어, 다양한 예외 상황과 네트워크의 불확실성을 고려한 섬세한 접근이 필요합니다. 견고한 오류 처리 로직과 사용자 중심의 UI/UX 개선을 통해 사용자에게 안정적이고 만족스러운 경험을 제공하는 것이 중요합니다. 