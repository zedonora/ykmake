# Day 19 - 개념 3: 타이핑 인디케이터와 Presence 활용

타이핑 인디케이터("상대방이 입력 중...")는 채팅 사용자 경험을 향상시키는 작은 기능입니다. 상대방이 응답을 준비하고 있음을 알려주어 대화의 흐름을 자연스럽게 만듭니다. Supabase Presence는 이 기능을 구현하는 데 효과적으로 사용될 수 있습니다.

## 1. 타이핑 인디케이터의 원리

*   **상태 공유**: 사용자가 메시지 입력 필드에 타이핑을 시작/중단할 때, 이 상태 변화를 실시간으로 상대방에게 알려야 합니다.
*   **실시간 전송**: 상태 변화 정보는 웹소켓과 같은 실시간 통신 채널을 통해 즉시 전달되어야 합니다.
*   **UI 피드백**: 상대방 클라이언트는 수신된 상태 정보를 바탕으로 "입력 중..."과 같은 시각적 피드백을 표시하거나 숨깁니다.

## 2. Presence를 이용한 구현 방법

Supabase Presence는 클라이언트 간의 임시 상태를 공유하는 데 이상적입니다. 데이터베이스에 직접 저장할 필요 없이 실시간으로 상태를 주고받을 수 있습니다.

1.  **상태 정의**: Presence `track()` 메소드로 전송할 페이로드에 `typing` (boolean)과 같은 필드를 추가합니다.
    ```javascript
    // Track할 페이로드 예시
    {
      user_id: 'user-abc', // 사용자 식별자
      online_at: '...',    // 온라인 상태 (기존)
      typing: true        // 타이핑 상태 추가
    }
    ```
2.  **타이핑 시작 감지**: 사용자가 입력 필드(`input`, `textarea`)에 입력을 시작하면 (`onChange` 이벤트), `channel.track({ ..., typing: true })`를 호출하여 타이핑 중임을 알립니다.
3.  **타이핑 중단 감지**: 여기가 조금 까다롭습니다. 사용자가 언제 타이핑을 멈출지 예측하기 어렵기 때문입니다. 일반적인 방법은 다음과 같습니다.
    *   **디바운스된 Timeout**: `onChange` 이벤트가 발생할 때마다 특정 시간(예: 2~3초) 후에 `channel.track({ ..., typing: false })`를 실행하는 `setTimeout`을 설정합니다. 만약 설정된 시간 내에 다시 `onChange` 이벤트가 발생하면, 이전 `setTimeout`을 `clearTimeout`으로 취소하고 새로운 `setTimeout`을 설정합니다. 이렇게 하면 마지막 타이핑 후 일정 시간이 지나면 자동으로 "타이핑 중단" 상태가 전송됩니다. (가장 일반적인 방법)
    *   **메시지 전송**: 메시지를 전송하는 시점(`onSubmit` 핸들러 내부)에는 명확히 타이핑이 끝난 것이므로, 이때 `typing: false` 상태를 `track`합니다. Timeout 방식과 함께 사용하면 더 확실합니다.
    *   **포커스 아웃 (Blur)**: 입력 필드에서 포커스가 벗어날 때(`onBlur` 이벤트) `typing: false`를 `track`할 수도 있습니다.
4.  **상태 수신 및 처리**: Presence 이벤트(`sync`, `join`) 핸들러에서 다른 사용자의 페이로드를 받을 때, `typing` 필드를 확인합니다.
    *   React 상태 변수(예: `isOpponentTyping`)를 만들어 상대방의 타이핑 상태를 관리합니다.
    *   `sync` 시 초기 상태를 설정하고, `join` 시 해당 사용자의 `typing` 상태를 반영하여 상태 변수를 업데이트합니다. `leave` 시에는 해당 사용자의 타이핑 상태를 고려할 필요가 없습니다 (어차피 오프라인).
5.  **UI 렌더링**: 상태 변수(`isOpponentTyping`) 값에 따라 UI에 "입력 중..." 텍스트나 애니메이션 등을 조건부로 렌더링합니다.

## 3. 디바운싱 (Debouncing) / 쓰로틀링 (Throttling)의 중요성

사용자가 타이핑할 때마다 `onChange` 이벤트는 매우 빈번하게 발생합니다. 이때마다 `channel.track()`을 호출하면 네트워크 트래픽이 과도하게 발생하고 서버 및 클라이언트에 불필요한 부하를 줄 수 있습니다.

*   **디바운싱 (Debouncing)**: 이벤트가 연속적으로 발생할 때, 마지막 이벤트 발생 후 일정 시간이 지날 때까지 기다렸다가 함수를 딱 한 번만 실행합니다. 타이핑 중단 감지(Timeout 방식)에 자연스럽게 적용됩니다. 타이핑 시작 알림(`typing: true`)에도 디바운스를 약하게 걸어 너무 빈번한 `track` 호출을 막을 수 있습니다 (예: 0.5초 이내의 연속 입력은 한 번만 `track`).
*   **쓰로틀링 (Throttling)**: 이벤트가 연속적으로 발생하더라도, 일정 시간 간격(예: 1초)으로 최대 한 번만 함수를 실행하도록 제한합니다. 타이핑 상태 업데이트에 사용할 수도 있지만, 디바운싱이 더 일반적으로 사용됩니다.

Lodash 라이브러리의 `debounce`, `throttle` 함수나 직접 구현하여 사용할 수 있습니다. 이를 통해 불필요한 `track` 호출을 줄여 성능을 개선해야 합니다.

## 4. 추가 고려사항

*   **상태 정확성**: Presence는 네트워크 지연 등으로 인해 약간의 딜레이가 있을 수 있습니다. 타이핑 인디케이터가 100% 정확하지 않을 수 있음을 인지해야 합니다.
*   **UI 위치**: 타이핑 인디케이터는 보통 채팅방 헤더 영역이나 메시지 목록 바로 위/아래 영역에 표시됩니다.
*   **여러 사용자**: 그룹 채팅방의 경우, 여러 사용자가 동시에 타이핑할 수 있습니다. "User1, User2님이 입력 중..."과 같이 여러 명을 표시하거나, "여러 명이 입력 중..."으로 간략하게 표시하는 방식을 고려해야 합니다. Presence 상태를 관리할 때 단순히 boolean이 아닌, 타이핑 중인 사용자 ID 목록을 관리해야 할 수 있습니다.

타이핑 인디케이터는 작은 기능이지만, Presence의 상태 공유 메커니즘을 잘 활용하면 비교적 간단하게 구현하여 사용자 경험을 향상시킬 수 있습니다. 