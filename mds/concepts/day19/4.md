# Day 19 - 개념 4: 메시지 읽음 처리 (Read Receipts)

메시지 읽음 확인 기능(Read Receipts)은 사용자가 보낸 메시지를 상대방이 언제 확인했는지 알려주는 기능입니다. 카카오톡의 '1'이 사라지거나 WhatsApp의 파란색 더블 체크가 대표적인 예입니다. 이 기능은 대화의 상태를 명확히 하고 사용자 간의 소통을 돕지만, 구현 방식에 따라 성능 및 프라이버시 측면에서 고려할 점이 있습니다.

## 1. 읽음 상태 추적 방법

*   **개별 메시지 상태 업데이트**:
    *   가장 일반적인 방법은 `messages` 테이블에 `read_at` (timestamp, nullable) 컬럼을 추가하는 것입니다. (Day 18 스키마에서 이미 추가됨)
    *   사용자가 메시지를 읽으면, 해당 메시지 레코드의 `read_at` 필드를 현재 시간으로 업데이트합니다.
    *   **장점**: 각 메시지별로 정확한 읽음 시간을 기록할 수 있습니다.
    *   **단점**: 여러 메시지를 한 번에 읽었을 때 다수의 UPDATE 작업이 발생할 수 있습니다. (물론 하나의 UPDATE 문으로 여러 행을 업데이트 가능)
*   **마지막 읽은 메시지 추적**:
    *   `rooms` 테이블이나 별도의 `read_status` 테이블에 각 사용자별로 해당 채팅방에서 마지막으로 읽은 메시지의 ID 또는 타임스탬프(`last_read_message_id` 또는 `last_read_at`)를 저장합니다.
    *   사용자가 방에 들어오면 이 값을 현재 시간 또는 가장 최근 메시지 ID로 업데이트합니다.
    *   메시지를 표시할 때, 해당 메시지의 `id` 또는 `created_at`이 사용자의 `last_read_message_id/at`보다 이전인지 비교하여 읽음 여부를 판단합니다.
    *   **장점**: 읽음 상태 업데이트가 사용자별/방별로 한 번만 발생하여 DB 쓰기 작업이 줄어듭니다.
    *   **단점**: 개별 메시지의 정확한 읽음 시간을 알 수 없습니다. "여기까지 읽음" 표시에 더 적합합니다.

## 2. 읽음 처리 시점 결정

언제 `read_at`을 업데이트하거나 `last_read_...`를 갱신할지 결정해야 합니다.

*   **채팅방 진입 시**: 사용자가 채팅방 컴포넌트를 마운트할 때, 해당 시점까지 도착한 모든 읽지 않은 메시지를 읽음 처리합니다. 가장 구현이 간단합니다.
*   **창/탭 활성화 시**: 브라우저의 Page Visibility API나 `window.onfocus` 이벤트를 사용하여 사용자가 해당 채팅방을 실제로 보고 있을 때 읽음 처리합니다. 백그라운드 탭에 있는 경우 읽음 처리되지 않도록 할 수 있습니다.
*   **새 메시지 도착 시**: 채팅방이 활성화된 상태에서 새 메시지가 도착하면 즉시 읽음 처리합니다.
*   **스크롤 위치 기반**: 사용자가 스크롤하여 특정 메시지가 화면에 보이는 순간 읽음 처리할 수도 있습니다. (구현 복잡도 증가)

일반적으로는 **채팅방 진입 시**와 **창 활성화 시** 읽음 처리를 하는 것이 사용자 경험과 구현 복잡성 사이의 좋은 균형점입니다.

## 3. 읽음 상태 업데이트 구현

`read_at` 컬럼을 업데이트하는 로직을 구현하는 방법입니다.

*   **클라이언트 직접 업데이트**: `supabase.from('messages').update(...)`를 사용합니다.
    *   **주의**: 다른 사용자가 보낸 메시지를 업데이트해야 하므로, RLS 정책에서 이를 허용하도록 설정해야 합니다. `UPDATE` 정책에서 `user_id != auth.uid()` 조건을 허용하되, 반드시 `room_id`가 사용자가 참여한 방인지 확인하는 등 보안에 매우 신중해야 합니다. 일반적으로 권장되지 않습니다.
*   **PostgreSQL 함수 (RPC)**: `mark_messages_as_read(p_room_id, p_reader_id)`와 같은 함수를 `SECURITY DEFINER` 또는 `SECURITY INVOKER` (RLS와 함께)로 생성하여 사용하는 것이 더 안전합니다. 함수 내부에서 권한 검증 및 업데이트 로직을 캡슐화할 수 있습니다. 클라이언트에서는 `supabase.rpc()`로 호출합니다.
*   **서버리스 함수/서버 액션**: 클라이언트가 서버(Edge Function, Remix Action 등)에 "방 진입" 이벤트를 보내면, 서버가 인증된 사용자를 대신하여 안전하게 데이터베이스 업데이트를 수행합니다. 보안적으로 가장 권장되는 방식 중 하나입니다.

## 4. UI 표시 방법

*   **개별 메시지**: 내가 보낸 메시지에 대해 상대방이 읽었음을 표시합니다.
    *   더블 체크 아이콘 (WhatsApp 스타일): 회색 -> 파란색
    *   텍스트 표시: "전송됨" -> "읽음"
    *   읽은 시간 표시 (선택적)
*   **채팅방 목록**: 각 채팅방별로 안 읽은 메시지 개수(`unread_count`)를 표시합니다. 이를 위해서는 `loader`에서 안 읽은 메시지 수를 계산하는 로직이 필요합니다. (`count()` 사용)
*   **마지막 메시지 기준**: 채팅방 목록이나 채팅방 내 마지막 메시지 옆에, 상대방이 이 마지막 메시지를 읽었는지 여부만 표시할 수도 있습니다.

## 5. 실시간 읽음 상태 업데이트

상대방이 내 메시지를 읽는 순간, 내 화면에도 '읽음' 표시가 실시간으로 업데이트되면 사용자 경험이 향상됩니다.

*   **Realtime `UPDATE` 이벤트 구독**: `messages` 테이블의 `UPDATE` 이벤트를 구독합니다. 콜백 함수에서 `payload.new`와 `payload.old`를 비교하여 `read_at` 필드가 `null`에서 값으로 변경되었는지 확인하고, 해당 메시지의 UI 상태를 업데이트합니다.
    *   **장점**: 비교적 간단하게 구현 가능합니다.
    *   **단점**: `read_at` 외 다른 필드가 업데이트될 때도 이벤트가 발생할 수 있으므로, 콜백 내에서 `read_at` 변경 여부를 명확히 확인해야 합니다. 여러 메시지가 동시에 읽음 처리되면 여러 이벤트가 발생할 수 있습니다.
*   **Realtime `Broadcast` 활용**: 읽음 처리 로직(RPC, 서버 액션 등)이 성공적으로 완료된 후, 해당 채널에 'messages-read'와 같은 커스텀 이벤트를 `broadcast`합니다. 페이로드에는 읽음 처리된 메시지 ID 목록이나 마지막 읽은 메시지 ID/시간 등을 포함할 수 있습니다. 클라이언트는 이 broadcast 이벤트를 구독하여 관련 메시지들의 상태를 한 번에 업데이트합니다.
    *   **장점**: 읽음 처리 완료 시점과 상태 업데이트 시점을 명확히 제어할 수 있습니다. 여러 메시지 업데이트를 하나의 이벤트로 처리하여 효율적일 수 있습니다.
    *   **단점**: Broadcast 이벤트를 보내는 로gic을 추가로 구현해야 합니다.

메시지 읽음 처리는 사용자에게 유용한 피드백을 제공하지만, 구현 방식과 업데이트 빈도, RLS 정책 등을 신중하게 설계하여 성능과 보안, 프라이버시를 모두 고려해야 합니다. 