# 실제 결제 흐름 연동 개념 설명

`jobs/day23/11.md`에서는 구축된 Toss Payments 결제 모듈을 실제 '아이디어 구매' 기능과 연결하는 과정을 다룹니다. 이는 단순히 결제 API를 호출하는 것을 넘어, 애플리케이션의 데이터 및 사용자 흐름과 통합하는 작업입니다.

## 1. 주문(Order) 엔티티의 중요성

결제를 시작하기 전에 **주문(Order)** 정보를 데이터베이스에 먼저 생성하는 것이 중요합니다. 주문은 다음과 같은 역할을 합니다.

- **결제 의도 기록**: 사용자가 어떤 상품(아이디어)을 얼마에 구매하려고 했는지 명확히 기록합니다.
- **상태 추적**: 결제 시도(PENDING), 성공(PAID), 실패(FAILED) 등 결제 과정의 상태를 관리합니다.
- **고유 식별자 제공 (`orderId`)**: Toss Payments API 호출 시 `orderId`를 사용하여 특정 거래를 식별하고, 결제 성공/실패 콜백 시에도 이 ID를 통해 어떤 주문에 대한 결과인지 파악할 수 있습니다.
- **서버 측 검증 기반**: 결제 성공 콜백 시, 클라이언트가 보낸 금액(`amount`)이 아닌, 서버에 저장된 주문의 `amount`와 비교하여 금액 위변조를 방지합니다.

`app/db/schema.ts`에 추가된 `orders` 테이블은 이러한 정보를 저장하기 위해 설계되었습니다. (`userId`, `ideaId`, `amount`, `status` 등)

## 2. 아이디어 구매 사용자 흐름

일반적인 아이디어 구매 흐름은 다음과 같습니다.

1.  **아이디어 탐색**: 사용자가 아이디어 목록을 보고 마음에 드는 아이디어를 선택합니다.
2.  **상세 정보 확인**: 아이디어 상세 페이지(`ideas/:ideaId`)에서 가격, 설명 등을 확인합니다.
3.  **구매 결정**: 사용자가 '구매하기' 버튼을 클릭합니다.
4.  **주문 생성 요청 (Server Action)**: 브라우저는 Remix 서버의 해당 라우트(`ideas/:ideaId`) 액션 함수로 'create-order' 요청을 보냅니다.
5.  **서버 처리 (Action)**:
    *   사용자 인증 및 아이디어 유효성(가격 등)을 확인합니다.
    *   `orders` 테이블에 새로운 주문 레코드를 생성합니다 (상태: `PENDING`).
    *   주문 생성 성공 시, 생성된 `orderId`를 포함하여 결제 페이지 (`/payments/checkout/:orderId`)로 리디렉션 응답을 보냅니다.
6.  **결제 페이지 이동**: 브라우저는 리디렉션 응답을 받아 결제 페이지로 이동합니다.
7.  **결제 진행**: `TossPaymentWidget`이 렌더링되고 사용자는 결제를 진행합니다. (Day 23, Step 9 & 10)
8.  **결제 결과 처리**: 결제 성공 또는 실패에 따라 `/payments/success` 또는 `/payments/fail`로 이동하여 서버에서 최종 처리됩니다.
9.  **후속 조치 (성공 시)**:
    *   서버는 `orders` 테이블의 상태를 `PAID`로 업데이트합니다.
    *   (선택 사항) 구매한 아이디어 접근 권한 부여 로직을 실행합니다.
    *   (선택 사항) 사용자에게 성공 메시지를 보여주거나 구매한 아이디어 페이지 등으로 리디렉션합니다.

## 3. 결제 성공과 애플리케이션 로직 연결

`/payments/success` 라우트의 `loader` 함수는 단순한 결제 상태 업데이트 이상의 역할을 할 수 있습니다. 여기서 애플리케이션의 특정 비즈니스 로직을 트리거해야 합니다.

- **접근 권한 부여**: 구매한 아이디어의 내용을 볼 수 있도록 권한을 부여합니다. (예: 별도의 `idea_purchases` 테이블에 기록하거나, 사용자-아이디어 간의 관계 테이블 상태 변경)
- **알림 발송**: 구매자 또는 판매자에게 구매 완료 알림을 보낼 수 있습니다.
- **통계 업데이트**: 서비스 내 구매 통계 등을 업데이트할 수 있습니다.

이러한 로직은 결제 상태가 `PAID`로 확실히 변경된 *후에* 실행되어야 합니다.

## 4. 동시성 및 오류 처리

- **중복 주문 방지**: 사용자가 '구매하기' 버튼을 짧은 시간 내에 여러 번 클릭하는 경우, 동일한 아이템에 대해 여러 개의 `PENDING` 주문이 생성될 수 있습니다.
    - `orders` 테이블에 `(userId, ideaId)`에 대한 `UNIQUE` 인덱스를 설정하면 데이터베이스 수준에서 중복 생성을 막을 수 있습니다.
    - 액션 함수에서 주문 생성 시 `try...catch` 블록을 사용하여 고유 인덱스 제약 조건 위반 오류(`error.code === '23505'` 등)를 감지하고, 이미 `PENDING` 상태인 주문이 있다면 해당 주문의 결제 페이지로 리디렉션하는 방식으로 처리할 수 있습니다.
- **일관성 유지**: 주문 생성, 결제 승인, 상태 업데이트 등 여러 단계에 걸쳐 데이터 일관성을 유지하는 것이 중요합니다. 트랜잭션 사용을 고려할 수 있지만, PG <-> Toss Payments API 호출이 섞여 있어 애플리케이션 레벨에서의 상태 관리 및 오류 복구 전략이 필요합니다.

이 단계를 통해 결제 시스템은 단순한 기술 연동을 넘어 서비스의 핵심 기능과 통합되어 사용자에게 실제 가치를 제공하게 됩니다. 