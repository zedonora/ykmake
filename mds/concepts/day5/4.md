# 개념 4: 기본 페이지네이션 컴포넌트 UI 구현

## 페이지네이션(Pagination)이란?

페이지네이션은 많은 양의 데이터를 여러 페이지로 나누어 보여주는 사용자 인터페이스(UI) 패턴입니다. 예를 들어, 수백 개의 제품 목록이나 게시글을 한 페이지에 모두 표시하면 로딩 시간이 길어지고 사용자가 정보를 탐색하기 어려워집니다. 페이지네이션은 데이터를 적절한 크기(예: 페이지당 10개 또는 20개)로 분할하고, 사용자가 페이지 번호를 클릭하거나 "다음"/"이전" 버튼을 통해 다른 데이터 페이지로 이동할 수 있도록 합니다.

## 페이지네이션의 필요성

*   **성능 향상:** 한 번에 적은 양의 데이터만 로드하므로 초기 페이지 로딩 속도가 빨라집니다.
*   **사용자 경험(UX) 개선:** 사용자는 압도적인 정보량 대신 관리 가능한 데이터 청크를 탐색할 수 있습니다.
*   **서버 부하 감소:** 서버는 전체 데이터가 아닌 요청된 페이지의 데이터만 처리하면 되므로 부하가 줄어듭니다.

## 일반적인 페이지네이션 UI 구성 요소

페이지네이션 컴포넌트는 일반적으로 다음과 같은 요소들을 포함합니다:

*   **페이지 번호 링크:** 사용자가 특정 페이지로 직접 이동할 수 있는 숫자 링크 (예: 1, 2, 3, ...).
*   **"다음" 및 "이전" 버튼:** 현재 페이지 기준으로 앞뒤 페이지로 이동하는 버튼.
*   **"처음" 및 "마지막" 버튼 (선택 사항):** 목록의 가장 첫 페이지 또는 마지막 페이지로 바로 이동하는 버튼.
*   **현재 페이지 표시:** 사용자가 현재 보고 있는 페이지 번호를 시각적으로 강조합니다.
*   **생략 부호 (...):** 페이지 수가 매우 많을 경우, 중간 페이지 번호들을 생략하고 표시하여 UI를 간결하게 유지합니다.

Shadcn/ui 라이브러리에도 `Pagination` 컴포넌트가 포함되어 있어 이를 활용하면 기본적인 스타일과 구조를 쉽게 구현할 수 있습니다.

## Remix에서의 페이지네이션 구현 방식

Remix에서 페이지네이션을 구현하는 일반적인 접근 방식은 다음과 같습니다:

1.  **URL 파라미터 사용:** 현재 페이지 번호 정보를 URL의 쿼리 파라미터(Query Parameter)를 통해 전달합니다. (예: `/products?page=2`)
2.  **`loader` 함수에서 페이지 정보 읽기:** `loader` 함수는 `request.url`을 통해 URL 쿼리 파라미터를 읽고, 현재 페이지 번호를 파악합니다.
3.  **데이터 조회 시 `limit` 및 `offset` 사용:** Drizzle ORM (또는 다른 데이터 조회 방법) 사용 시, `loader`에서 파악한 페이지 번호를 기반으로 `limit`(페이지당 항목 수)과 `offset`(건너뛸 항목 수) 값을 계산하여 해당 페이지의 데이터만 조회합니다.
4.  **총 항목 수 및 페이지 수 계산:** `loader` 함수는 요청된 페이지의 데이터뿐만 아니라, 전체 항목 수(또는 전체 페이지 수)도 계산하여 페이지네이션 컴포넌트를 렌더링하는 데 필요한 정보를 함께 반환합니다.
5.  **페이지네이션 UI 컴포넌트 렌더링:** 페이지 컴포넌트는 `useLoaderData`를 통해 데이터와 페이지 정보를 받아옵니다. 이 정보를 기반으로 페이지네이션 UI 컴포넌트(예: Shadcn/ui의 `Pagination`)를 렌더링합니다.
6.  **페이지 이동 처리:** 페이지네이션 컴포넌트의 각 페이지 번호 링크나 버튼은 해당 페이지 번호를 포함하는 새로운 URL(예: `/products?page=3`)로 사용자를 이동시킵니다. Remix는 이 URL 변경을 감지하고 해당 라우트의 `loader` 함수를 다시 실행하여 새 페이지의 데이터를 로드합니다.

## UI 컴포넌트 구현 시 고려사항

*   **재사용성:** 페이지네이션 로직은 제품 목록, 게시글 목록 등 여러 곳에서 필요할 수 있으므로, 재사용 가능한 컴포넌트로 만드는 것이 좋습니다.
*   **상태 관리:** 현재 페이지, 전체 페이지 수 등의 상태를 컴포넌트 내부 또는 외부(props 전달)에서 관리하는 방식을 결정해야 합니다.
*   **접근성:** 키보드 네비게이션 및 스크린 리더 사용자를 고려하여 시맨틱 HTML과 적절한 ARIA 속성을 사용해야 합니다.
*   **디자인:** 데모 사이트 또는 애플리케이션의 전반적인 디자인 시스템과 일관성을 유지합니다.

다음 작업에서는 Shadcn/ui의 `Pagination` 컴포넌트를 기반으로 기본적인 페이지네이션 UI 컴포넌트(`app/components/ui/PaginationControls.tsx` 등)를 생성하는 코드를 작성합니다. 초기에는 데이터 연동 없이 UI 구조와 스타일링에 집중합니다. 

# 작업 4 개념: Supabase 연동 설정 및 환경 변수 관리

Remix 애플리케이션에서 Supabase의 인증 및 데이터베이스 기능을 사용하기 위한 초기 설정 과정입니다.

## 핵심 개념

1.  **필수 라이브러리:**
    *   **`@supabase/supabase-js`:** Supabase와 상호작용하기 위한 핵심 JavaScript 클라이언트 라이브러리입니다.
    *   **`@supabase/ssr`:** 서버 사이드 렌더링(SSR) 환경(Remix 등)에서 Supabase 인증을 안전하고 효과적으로 처리하기 위한 헬퍼 라이브러리입니다. 쿠키 기반의 세션 관리를 용이하게 해줍니다. (과거 `@supabase/auth-helpers-remix`를 대체 또는 보강)

2.  **환경 변수 (`.env`):**
    *   애플리케이션 설정 중 외부에 노출되어서는 안 되는 민감한 정보(API 키, 데이터베이스 URL 등)를 코드와 분리하여 관리하는 방법입니다.
    *   **`SUPABASE_URL`:** Supabase 프로젝트의 고유 URL입니다.
    *   **`SUPABASE_ANON_KEY`:** Supabase의 "anonymous" 키입니다. 클라이언트 측에서 사용자의 행위를 식별하고 RLS(Row Level Security) 정책을 적용하는 데 사용되는 공개 키입니다. **서비스 역할 키(`SERVICE_ROLE_KEY`)와 혼동하지 않도록 주의해야 합니다.**
    *   **`.gitignore`:** `.env` 파일은 절대 Git 저장소에 커밋되어서는 안 되므로, `.gitignore` 파일에 반드시 추가하여 추적되지 않도록 합니다.

3.  **서버 클라이언트 생성 (`app/lib/supabase.server.ts`):**
    *   Remix의 서버 환경(`loader`, `action` 함수)에서 Supabase와 통신하기 위한 클라이언트를 생성하는 함수(`createSupabaseServerClient`)를 정의합니다.
    *   **`@supabase/ssr`의 `createServerClient`:** 이 함수는 요청(Request) 객체로부터 쿠키를 읽고, Supabase 작업 중 발생하는 세션 변경(로그인, 로그아웃 등)을 응답(Response) 헤더의 `Set-Cookie`로 설정하는 로직을 포함합니다.
    *   **쿠키 관리:**
        *   `parse(request.headers.get('Cookie') ?? '')`: 요청 헤더에서 쿠키 문자열을 객체로 파싱합니다.
        *   `serialize(key, value, options)`: 응답 헤더에 설정할 쿠키 문자열을 생성합니다.
        *   `createServerClient`의 `cookies` 옵션 내 `get`, `set`, `remove` 함수는 Remix의 요청/응답 사이클 내에서 Supabase 인증 상태를 쿠키를 통해 안전하게 동기화하는 역할을 합니다.
    *   반환값: 생성된 `supabase` 클라이언트 인스턴스와, 쿠키 설정을 위한 `headers` 객체를 함께 반환합니다.

4.  **Supabase 타입 생성 (`app/types/supabase.d.ts`):**
    *   `supabase gen types typescript` CLI 명령어를 사용하면 Supabase 데이터베이스 스키마를 기반으로 TypeScript 타입을 자동으로 생성할 수 있습니다.
    *   이렇게 생성된 `Database` 타입을 `createServerClient<Database>(...)`와 같이 제네릭으로 넘겨주면, `supabase.from('테이블명').select()` 등을 사용할 때 자동 완성 및 타입 검사 기능을 활용하여 개발 생산성과 코드 안정성을 크게 높일 수 있습니다.

5.  **루트 로더 (`app/root.tsx` `loader`):**
    *   애플리케이션의 모든 페이지 요청 시 가장 먼저 실행되는 `loader` 중 하나입니다.
    *   `createSupabaseServerClient(request)`를 호출하여 현재 요청에 대한 Supabase 클라이언트와 헤더를 가져옵니다.
    *   `supabase.auth.getSession()`: 현재 요청의 쿠키를 기반으로 사용자의 세션 정보(로그인 상태 등)를 가져옵니다.
    *   **환경 변수 전달:** 클라이언트 측 JavaScript에서도 Supabase 클라이언트를 초기화하려면 `SUPABASE_URL`과 `SUPABASE_ANON_KEY`가 필요합니다. `loader`에서 `process.env`로부터 이 값들을 읽어 `env` 객체로 만듭니다. **절대 `SERVICE_ROLE_KEY` 같은 민감한 키를 클라이언트로 전달하면 안 됩니다.**
    *   **데이터 반환 (`json`):** `loader`는 `env` 객체와 `session` 정보를 담은 객체를 `json()` 유틸리티 함수를 사용하여 반환합니다. 이때, 서버 클라이언트 생성 시 반환된 `headers` 객체를 `json()` 함수의 두 번째 인자로 전달해야 Supabase 인증 상태 변경(로그인/로그아웃 시 쿠키 설정)이 정상적으로 반영됩니다.

6.  **클라이언트 환경 변수 주입 (`app/root.tsx` `App`):**
    *   `useLoaderData` 훅으로 `loader`에서 반환한 `env` 객체를 가져옵니다.
    *   이 `env` 객체를 클라이언트 측 JavaScript에서 사용할 수 있도록 `window.env = ${JSON.stringify(env)}`와 같은 스크립트를 HTML에 포함시켜 전역 변수로 만듭니다. (다른 방식으로는 Remix의 `context` 사용 등이 있습니다.)

## 기대 효과

*   Remix 서버 환경에서 Supabase와 안전하게 통신할 수 있습니다.
*   쿠키 기반으로 사용자의 인증 상태(세션)를 관리할 수 있습니다.
*   환경 변수를 통해 민감한 설정을 코드와 분리하여 관리합니다.
*   (타입 생성 시) 개발 과정에서 타입 안전성을 확보할 수 있습니다.
*   클라이언트 측에서도 Supabase 클라이언트를 초기화할 준비가 됩니다. 