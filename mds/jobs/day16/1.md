# Day 16 - 작업 1: 추천(Upvotes) 테이블 스키마 정의

사용자가 제품(products)이나 게시글(posts) 등 특정 리소스를 추천(upvote)할 수 있는 기능을 구현하기 위해 필요한 데이터베이스 테이블(`upvotes`)의 스키마를 정의합니다.

## 목표

*   `upvotes` 테이블을 생성하여 어떤 사용자가 어떤 리소스(제품 또는 게시글)를 추천했는지 기록합니다.
*   테이블 컬럼을 정의하고 적절한 데이터 타입을 설정합니다. (예: `user_id`, `product_id`, `post_id`, `created_at`)
*   기본 키(Primary Key) 및 외래 키(Foreign Key) 제약 조건을 설정하여 데이터 무결성을 보장합니다.
*   한 사용자가 동일한 리소스를 여러 번 추천할 수 없도록 제약 조건을 추가합니다. (Unique Constraint)
*   테이블에 대한 RLS(Row Level Security) 정책을 활성화하고 기본 정책을 설정합니다.

## 작업 단계

### 1. `upvotes` 테이블 생성 (SQL)

Supabase 대시보드의 SQL Editor 또는 마이그레이션 도구를 사용하여 다음 SQL 쿼리를 실행하여 `upvotes` 테이블을 생성합니다.

```sql
-- 추천(Upvotes) 테이블 생성
CREATE TABLE public.upvotes (\n    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- 고유 ID (선택 사항이지만 관리 편의상 추가)\n    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE, -- 추천한 사용자 ID (profiles 테이블 참조)\n    product_id BIGINT REFERENCES public.products(id) ON DELETE CASCADE, -- 추천된 제품 ID (products 테이블 참조, NULL 가능)\n    post_id BIGINT REFERENCES public.posts(id) ON DELETE CASCADE, -- 추천된 게시글 ID (posts 테이블 참조, NULL 가능)\n    created_at TIMESTAMPTZ DEFAULT now() NOT NULL, -- 추천 시각\n\n    -- 제약 조건: product_id 또는 post_id 둘 중 하나는 반드시 값이 있어야 함\n    CONSTRAINT check_resource_id CHECK (product_id IS NOT NULL OR post_id IS NOT NULL),\n\n    -- 제약 조건: 한 사용자는 동일한 제품을 한 번만 추천 가능\n    CONSTRAINT unique_user_product_upvote UNIQUE (user_id, product_id),\n\n    -- 제약 조건: 한 사용자는 동일한 게시글을 한 번만 추천 가능\n    CONSTRAINT unique_user_post_upvote UNIQUE (user_id, post_id)\n);\n\n-- 테이블 설명 추가 (선택 사항)\nCOMMENT ON TABLE public.upvotes IS \'사용자의 제품 또는 게시글 추천 기록\';\nCOMMENT ON COLUMN public.upvotes.user_id IS \'추천을 누른 사용자 ID\';\nCOMMENT ON COLUMN public.upvotes.product_id IS \'추천받은 제품 ID (제품 추천인 경우)\';\nCOMMENT ON COLUMN public.upvotes.post_id IS \'추천받은 게시글 ID (게시글 추천인 경우)\';\n\n-- 인덱스 추가 (조회 성능 향상을 위해)\nCREATE INDEX idx_upvotes_user_id ON public.upvotes(user_id);\nCREATE INDEX idx_upvotes_product_id ON public.upvotes(product_id);\nCREATE INDEX idx_upvotes_post_id ON public.upvotes(post_id);\n```

**스키마 설명:**

*   `id`: 각 추천 기록의 고유 식별자입니다. 복합 키 대신 단일 PK를 사용할 경우 관리가 용이할 수 있습니다.
*   `user_id`: 추천을 한 사용자의 ID입니다. `profiles` 테이블의 `id`를 참조하는 외래 키이며, 사용자가 삭제되면 관련 추천 기록도 함께 삭제됩니다 (`ON DELETE CASCADE`).
*   `product_id`: 추천된 제품의 ID입니다. `products` 테이블의 `id`를 참조하며, 제품이 삭제되면 관련 추천 기록도 삭제됩니다. 제품 추천이 아닌 경우 `NULL`이 될 수 있습니다.
*   `post_id`: 추천된 게시글의 ID입니다. `posts` 테이블의 `id`를 참조하며, 게시글이 삭제되면 관련 추천 기록도 삭제됩니다. 게시글 추천이 아닌 경우 `NULL`이 될 수 있습니다.
*   `created_at`: 추천이 기록된 시각입니다.
*   `check_resource_id` 제약 조건: `product_id`와 `post_id` 중 적어도 하나는 `NULL`이 아니어야 함을 보장합니다. (어떤 리소스에 대한 추천인지 명확히 하기 위함)
*   `unique_user_product_upvote` 제약 조건: `user_id`와 `product_id` 조합의 유일성을 보장하여, 한 사용자가 같은 제품을 여러 번 추천하는 것을 방지합니다. (`product_id`가 `NULL`인 경우는 이 제약 조건에 영향을 받지 않습니다.)
*   `unique_user_post_upvote` 제약 조건: `user_id`와 `post_id` 조합의 유일성을 보장하여, 한 사용자가 같은 게시글을 여러 번 추천하는 것을 방지합니다.

**대안: 복합 기본 키 사용**

만약 `id` 컬럼 없이 `(user_id, product_id)` 또는 `(user_id, post_id)` 자체를 기본 키로 사용하고 싶다면, 테이블 정의를 다르게 해야 합니다. 이는 NULL 값을 포함할 수 없는 기본 키의 특성상, 제품 추천과 게시글 추천을 별도의 테이블로 분리하거나 다른 구조를 고려해야 할 수 있습니다. 위 예시는 단일 테이블에서 처리하기 위해 별도의 `id` PK를 사용했습니다.

### 2. RLS(Row Level Security) 활성화 및 정책 설정

보안을 위해 `upvotes` 테이블에 RLS를 활성화하고 기본 정책을 설정합니다.

```sql
-- upvotes 테이블에 RLS 활성화
ALTER TABLE public.upvotes ENABLE ROW LEVEL SECURITY;

-- 정책: 로그인한 사용자는 자신의 추천 기록을 조회/삭제할 수 있음
CREATE POLICY "Allow own read and delete access"
ON public.upvotes
FOR SELECT, DELETE USING (auth.uid() = user_id);

-- 정책: 로그인한 사용자는 추천을 생성(INSERT)할 수 있음
CREATE POLICY "Allow authenticated insert access"
ON public.upvotes
FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);

-- 참고: 다른 사람의 추천 기록을 조회해야 하는 경우 (예: 추천 수 집계), 별도의 SELECT 정책이나 Security Definer 함수가 필요할 수 있습니다.
-- 예시: 모든 사용자가 모든 추천 기록을 읽을 수 있게 하려면 (일반적으로 권장되지 않음)
-- CREATE POLICY "Allow public read access" ON public.upvotes FOR SELECT USING (true);
```

**RLS 정책 설명:**

*   RLS를 활성화하여 기본적으로 테이블 접근을 차단합니다.
*   `Allow own read and delete access` 정책: 사용자가 `SELECT` 또는 `DELETE` 작업을 할 때, 해당 레코드의 `user_id`가 현재 로그인한 사용자의 ID (`auth.uid()`)와 일치하는 경우에만 허용합니다. 즉, 자신의 추천 기록만 조회하거나 취소(삭제)할 수 있습니다.
*   `Allow authenticated insert access` 정책: 로그인한 사용자(`authenticated` 역할)가 `INSERT` 작업을 할 때, 삽입하려는 데이터의 `user_id`가 자신의 ID와 일치하는 경우에만 허용합니다. 즉, 다른 사용자의 이름으로 추천을 기록할 수 없습니다.

## 예상 결과

*   `public` 스키마에 `upvotes` 테이블이 성공적으로 생성됩니다.
*   테이블에는 `id`, `user_id`, `product_id`, `post_id`, `created_at` 컬럼이 정의되어 있습니다.
*   `user_id`, `product_id`, `post_id` 컬럼에 외래 키 제약 조건이 설정됩니다.
*   `check_resource_id`, `unique_user_product_upvote`, `unique_user_post_upvote` 제약 조건이 설정됩니다.
*   테이블 조회 성능 향상을 위한 인덱스가 생성됩니다.
*   `upvotes` 테이블에 RLS가 활성화되고, 자신의 기록에 대한 CRUD 및 추천 생성 정책이 적용됩니다.

## 체크리스트

*   [ ] `upvotes` 테이블이 SQL을 통해 성공적으로 생성되었는가?
*   [ ] 모든 필수 컬럼(`user_id`, `created_at`)과 선택적 리소스 컬럼(`product_id`, `post_id`), PK(`id`)가 정의되었는가?
*   [ ] 외래 키 (`user_id`, `product_id`, `post_id`) 제약 조건이 올바르게 설정되었는가? (`ON DELETE CASCADE` 포함)
*   [ ] `check_resource_id` 제약 조건이 설정되었는가?
*   [ ] 유니크 제약 조건 (`unique_user_product_upvote`, `unique_user_post_upvote`)이 설정되었는가?
*   [ ] RLS가 `upvotes` 테이블에 활성화되었는가?
*   [ ] 자신의 추천 기록 조회/삭제 및 추천 생성에 대한 RLS 정책이 올바르게 설정되었는가?
``` 