# Day 16 - 작업 4: Optimistic UI 적용\n\n이전 작업에서 `useFetcher`를 사용하여 추천 버튼 클릭 시 페이지 리로드 없이 Action을 호출하도록 개선했습니다. 하지만 Action이 완료되고 서버로부터 응답을 받기 전까지는 UI가 변경되지 않아 사용자에게 즉각적인 피드백을 주지 못하는 단점이 있었습니다.\n\n이번 작업에서는 **Optimistic UI (낙관적 UI)** 패턴을 적용하여, 사용자가 버튼을 클릭하는 즉시 UI를 성공 상태로 미리 업데이트하고, 실제 서버 응답을 받은 후 필요하다면 상태를 조정하는 방법을 구현합니다.\n\n## 목표\n\n*   Optimistic UI 패턴의 개념과 장점을 이해합니다.\n*   `useFetcher` 훅과 함께 Optimistic UI를 구현하는 방법을 학습합니다.\n*   `UpvoteButton` 컴포넌트에 Optimistic UI를 적용하여, 버튼 클릭 즉시 추천 상태와 카운트가 변경되도록 합니다.\n*   `fetcher.formData`를 사용하여 사용자의 의도(추천/추천 취소)를 파악하고 Optimistic 업데이트에 활용합니다.\n\n## 작업 단계\n\n### 1. `UpvoteButton` 컴포넌트에 Optimistic UI 로직 추가 (`app/components/upvote-button.tsx`)\n\n1.  **Optimistic 상태 계산**: `fetcher.state`가 `submitting` 상태일 때, `fetcher.formData`를 확인하여 사용자가 어떤 액션(추천 또는 추천 취소)을 의도했는지 파악하고, 이를 기반으로 UI 상태를 미리 계산합니다.\n    *   `fetcher.formData.get(\"currentlyUpvoted\") === \'false\'` 이면 사용자가 \'추천\'을 시도한 것이므로, `optimisticUpvoted`는 `true`가 되고 `optimisticUpvoteCount`는 1 증가합니다.\n    *   `fetcher.formData.get(\"currentlyUpvoted\") === \'true\'` 이면 사용자가 \'추천 취소\'를 시도한 것이므로, `optimisticUpvoted`는 `false`가 되고 `optimisticUpvoteCount`는 1 감소합니다.\n2.  **현재 UI 상태 결정**: `fetcher`가 `idle` 상태일 때는 `loader`로부터 받은 초기값(`initialUpvoted`, `initialUpvoteCount`)을 사용하고, `submitting` 상태일 때는 위에서 계산한 Optimistic 상태 값을 사용합니다.\n3.  **UI 렌더링**: 계산된 현재 UI 상태 (`displayUpvoted`, `displayUpvoteCount`)를 사용하여 버튼의 스타일과 추천 수를 렌더링합니다.\n\n### 수정된 `UpvoteButton` 컴포넌트 예시\n\n```typescript\n// app/components/upvote-button.tsx (Optimistic UI 적용)\nimport { useFetcher } from \"@remix-run/react\";\nimport { Button } from \"~/components/ui/button\";\nimport { ArrowUp } from \"lucide-react\";\nimport { useEffect, useState } from \"react\"; // useState, useEffect 추가\n\ninterface UpvoteButtonProps {\n  resourceId: number | string;\n  resourceType: \'product\' | \'post\';\n  initialUpvoted: boolean;\n  initialUpvoteCount: number;\n}\n\nexport function UpvoteButton({\n  resourceId,\n  resourceType,\n  initialUpvoted,\n  initialUpvoteCount,\n}: UpvoteButtonProps) {\n  const fetcher = useFetcher<{ success?: boolean; error?: string }>();\n\n  // 로컬 UI 상태 관리용 state (서버 응답 후 실제 값 반영 위해)\n  // 초기값은 loader에서 받아온 값으로 설정\n  const [isUpvoted, setIsUpvoted] = useState(initialUpvoted);\n  const [upvoteCount, setUpvoteCount] = useState(initialUpvoteCount);\n\n  // initial 값이 변경될 때 로컬 state 업데이트 (네비게이션 등으로 데이터 갱신 시)\n  useEffect(() => {\n    setIsUpvoted(initialUpvoted);\n    setUpvoteCount(initialUpvoteCount);\n  }, [initialUpvoted, initialUpvoteCount]);\n\n\n  // Optimistic UI를 위한 상태 계산\n  let displayUpvoted = isUpvoted;\n  let displayUpvoteCount = upvoteCount;\n\n  if (fetcher.formData) {\n    // fetcher.formData가 존재하면 = 현재 제출 중(submitting) 상태\n    const submittedCurrentlyUpvoted = fetcher.formData.get(\"currentlyUpvoted\") === \"true\";\n    // 사용자의 의도와 반대로 UI를 미리 업데이트\n    displayUpvoted = !submittedCurrentlyUpvoted;\n    displayUpvoteCount = submittedCurrentlyUpvoted\n      ? upvoteCount - 1 // 추천 취소 시도 -> 카운트 감소\n      : upvoteCount + 1; // 추천 시도 -> 카운트 증가\n  }\n\n  // 서버 응답 처리 (선택적이지만 권장):\n  // 만약 Action이 실패하면 Optimistic 업데이트를 되돌릴 수 있음\n  useEffect(() => {\n    // fetcher.state가 idle로 돌아왔고, fetcher.data가 있고, 성공하지 못했다면(에러 발생)\n    if (fetcher.state === \"idle\" && fetcher.data && !fetcher.data.success) {\n       // Optimistic 업데이트를 되돌린다 (원래 상태로 복구)\n       // 이 예시에서는 간단히 원래 initial 값으로 돌리지만,\n       // 더 정교하게는 이전 상태를 저장했다가 복구할 수 있다.\n       console.warn(\"Optimistic update failed, reverting UI.\");\n       setIsUpvoted(initialUpvoted);\n       setUpvoteCount(initialUpvoteCount);\n       // 사용자에게 에러 피드백 (예: toast)\n       // showToast(\"Error: \" + fetcher.data.error);\n    }\n    // 성공한 경우에는 별도로 state를 업데이트할 필요 없음.\n    // 데이터 일관성을 위해서는 loader 데이터 재검증(revalidate)을 유발하는 것이 좋음\n    // (예: fetcher 대신 useSubmit + useNavigate 사용 또는 수동 revalidate)\n    // 하지만 이 예제에서는 Optimistic 업데이트가 최종 상태라고 가정.\n  }, [fetcher.state, fetcher.data, initialUpvoted, initialUpvoteCount]);\n\n\n  const isSubmitting = fetcher.state !== \"idle\";\n\n  return (\n    <fetcher.Form method=\"post\" action=\"/api/upvote\">\n      <input type=\"hidden\" name=\"_action\" value=\"upvote\" />\n      <input type=\"hidden\" name=\"resourceId\" value={resourceId} />\n      <input type=\"hidden\" name=\"resourceType\" value={resourceType} />\n      {/* 중요: 현재 실제 상태(isUpvoted)를 전송해야 Action이 올바르게 동작 */}\n      <input type=\"hidden\" name=\"currentlyUpvoted\" value={String(isUpvoted)} />\n\n      <Button\n        type=\"submit\"\n        // Optimistic 상태(displayUpvoted)를 사용하여 UI 렌더링\n        variant={displayUpvoted ? \"default\" : \"outline\"}\n        size=\"sm\"\n        disabled={isSubmitting}\n        className=\"flex items-center space-x-1\"\n        aria-label={displayUpvoted ? \"추천 취소\" : \"추천하기\"}\n      >\n        <ArrowUp className={`h-4 w-4 ${displayUpvoted ? \'\' : \'\'}`} />\n        {/* Optimistic 상태(displayUpvoteCount)를 사용하여 UI 렌더링 */}\n        <span>{displayUpvoteCount}</span>\n         {/* {isSubmitting && <Spinner />} */}\n      </Button>\n       {/* 에러 메시지 표시 (선택적) */}\n       {fetcher.data?.error && !fetcher.data.success && (\n         <p className=\"text-red-500 text-xs mt-1\">{fetcher.data.error}</p>\n       )}\n    </fetcher.Form>\n  );\n}\n```\n\n**주요 변경 사항:**\n\n*   `useState`와 `useEffect`를 사용하여 컴포넌트의 로컬 상태(`isUpvoted`, `upvoteCount`)를 관리합니다. 이는 `initialProps`가 변경되거나 서버 응답 후 상태를 조정할 때 필요합니다.\n*   `fetcher.formData`가 존재할 때(즉, `submitting` 상태일 때) 사용자의 제출 의도를 파악하여 `displayUpvoted`와 `displayUpvoteCount`를 낙관적으로 계산합니다.\n*   버튼의 `variant`, `aria-label`, 추천 수 표시에 `initial` 값 대신 계산된 `displayUpvoted`, `displayUpvoteCount`를 사용합니다.\n*   폼의 숨겨진 필드 `currentlyUpvoted`에는 Optimistic 값이 아닌, 현재 **실제** 상태인 `isUpvoted`를 전송해야 Action 함수가 올바른 로직(INSERT 또는 DELETE)을 수행할 수 있습니다.\n*   (선택 사항) `useEffect`를 추가하여 Action 실패 시 Optimistic 업데이트를 되돌리는 로직을 구현할 수 있습니다.\n\n## 예상 결과\n\n*   사용자가 추천 버튼을 클릭하면, 서버 응답을 기다리지 않고 **즉시** 버튼의 스타일(추천됨/안됨)과 추천 수가 변경됩니다.\n*   버튼은 여전히 `fetcher.state`에 따라 Action 실행 중 비활성화됩니다.\n*   백그라운드에서 Action이 실행되고 데이터베이스가 업데이트됩니다.\n*   (오류 처리 로직 추가 시) 만약 Action 실행 중 서버에서 오류가 발생하면, UI가 원래 상태로 되돌아가고 사용자에게 오류 피드백을 줄 수 있습니다.\n*   페이지를 새로고침해도 최종적으로 서버에 반영된 상태가 올바르게 표시됩니다.\n\n## 체크리스트\n\n*   [ ] `UpvoteButton` 컴포넌트에서 `fetcher.formData`를 사용하여 사용자의 제출 의도를 파악하는 로직이 있는가?\n*   [ ] `fetcher`가 `submitting` 상태일 때, UI에 표시될 추천 상태(`displayUpvoted`)와 추천 수(`displayUpvoteCount`)를 낙관적으로 계산하는 로직이 있는가?\n*   [ ] 버튼 렌더링 시 `initial` 값 대신 계산된 Optimistic 상태 값을 사용하는가?\n*   [ ] `<fetcher.Form>`의 숨겨진 필드 `currentlyUpvoted`에는 Optimistic 값이 아닌 **실제** 상태 값이 전송되는가?\n*   [ ] 버튼 클릭 시 UI가 즉시 변경되는 것을 확인했는가?\n*   [ ] (선택 사항) 로컬 상태 관리를 위해 `useState`, `useEffect`가 사용되었는가?\n*   [ ] (선택 사항) Action 실패 시 Optimistic 업데이트를 되돌리는 오류 처리 로직이 구현되었는가?\n``` 