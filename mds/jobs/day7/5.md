# Day 7 - 작업 5: 인증 폼 배경 애니메이션 구현

인증 폼(`AuthForm`)의 2단 레이아웃 중 왼쪽 패널에 동적인 픽셀 애니메이션 배경 효과를 추가합니다. 이를 위해 `canvas`를 사용하는 별도의 React 컴포넌트(`AnimatedBackground`)를 생성하고 `AuthForm`에 통합합니다.

## 주요 구현 내용

1.  **`AnimatedBackground` 컴포넌트 (`app/components/custom/animated-background.tsx`)**:
    *   React의 `useRef`와 `useEffect` 훅을 사용합니다.
    *   `canvas` 요소에 대한 참조(`canvasRef`)를 생성합니다.
    *   `useEffect` 내에서 `canvas` 컨텍스트를 가져옵니다.
    *   픽셀 크기(`pixelSize`), 기본 색상(`baseColor`), 활성 색상(`activeColor`), 업데이트 간격(`updateInterval`) 등을 정의합니다.
    *   Canvas 크기가 변경될 때 격자를 다시 초기화하고 그리는 `resizeCanvas` 함수를 구현합니다.
    *   Canvas 크기에 맞춰 픽셀 격자 데이터를 생성하는 `initializeGrid` 함수를 구현합니다.
    *   `requestAnimationFrame`을 사용하여 애니메이션 루프를 실행하는 `drawGrid` 함수를 구현합니다.
        *   매 프레임마다 Canvas를 기본 색상으로 지웁니다.
        *   `updateInterval`마다 일부 픽셀의 색상을 무작위로 활성 색상 또는 기본 색상으로 변경합니다.
        *   격자 데이터를 기반으로 각 픽셀(사각형)을 그립니다. (약간의 간격을 위해 `pixelSize`보다 작게 그림)
    *   컴포넌트 마운트 시 `resizeCanvas`를 호출하여 초기화하고, `resize` 이벤트 리스너를 추가합니다.
    *   애니메이션 프레임을 시작합니다.
    *   컴포넌트 언마운트 시 `cancelAnimationFrame`을 호출하고 이벤트 리스너를 제거하는 클린업 함수를 반환합니다.
2.  **`AuthForm` 컴포넌트 통합 (`app/components/custom/auth-form.tsx`)**:
    *   `AnimatedBackground` 컴포넌트를 import합니다.
    *   2단 레이아웃의 왼쪽 패널 (`<div class="hidden lg:block relative">`) 내부에 `<AnimatedBackground />`를 렌더링합니다.
    *   왼쪽 패널의 기존 배경색 클래스(`bg-zinc-900`)는 `AnimatedBackground` 내부에서 처리되므로 제거합니다.

## 코드: `AnimatedBackground` 컴포넌트

!!!typescript
import React, { useRef, useEffect } from 'react';

const AnimatedBackground: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationFrameId = useRef<number | undefined>(undefined);
  const grid = useRef<{ x: number; y: number; color: string }[]>([]);
  const lastUpdateTime = useRef<number>(0);
  const updateInterval = 100; // 밀리초 단위 (0.1초마다 업데이트)
  const pixelSize = 6; // 픽셀 크기 줄임 (10 -> 6)
  const baseColor = '#18181b'; // 기본 배경색 (zinc-900)
  const activeColor = '#e11d48'; // 활성 픽셀 색상 변경 (rose-500 -> rose-600)

  useEffect(() => {
    const canvas = canvasRef.current;
    const context = canvas?.getContext('2d');
    let container: HTMLElement | null = null;

    if (!canvas || !context) {
      return;
    }

    const resizeCanvas = () => {
      container = canvas.parentElement;
      if (container) {
        canvas.width = container.offsetWidth;
        canvas.height = container.offsetHeight;
        initializeGrid();
        drawGrid(performance.now()); // Resize 후 즉시 다시 그리기
      }
    };

    const initializeGrid = () => {
      grid.current = [];
      const cols = Math.ceil(canvas.width / pixelSize);
      const rows = Math.ceil(canvas.height / pixelSize);
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          grid.current.push({
            x: i * pixelSize,
            y: j * pixelSize,
            color: baseColor,
          });
        }
      }
    };

    const drawGrid = (timestamp: number) => {
      // Clear canvas
      context.fillStyle = baseColor;
      context.fillRect(0, 0, canvas.width, canvas.height);

      // Update colors periodically
      if (timestamp - lastUpdateTime.current > updateInterval) {
        lastUpdateTime.current = timestamp;
        // Randomly change some pixels to active color and some back to base color
        const pixelsToActivate = Math.floor(grid.current.length * 0.01); // 1% 활성화
        const pixelsToDeactivate = Math.floor(grid.current.length * 0.01); // 1% 비활성화

        for (let i = 0; i < pixelsToActivate; i++) {
          const randomIndex = Math.floor(Math.random() * grid.current.length);
          grid.current[randomIndex].color = activeColor;
        }
        for (let i = 0; i < pixelsToDeactivate; i++) {
          const randomIndex = Math.floor(Math.random() * grid.current.length);
          if (grid.current[randomIndex].color === activeColor) {
            grid.current[randomIndex].color = baseColor;
          }
        }
      }

      // Draw pixels
      grid.current.forEach(pixel => {
        context.fillStyle = pixel.color;
        // 작은 틈을 위해 pixelSize보다 약간 작게 그립니다.
        context.fillRect(pixel.x + 1, pixel.y + 1, pixelSize - 2, pixelSize - 2);
      });

      animationFrameId.current = requestAnimationFrame(drawGrid);
    };

    resizeCanvas(); // Initial setup
    window.addEventListener('resize', resizeCanvas);

    // Start animation
    animationFrameId.current = requestAnimationFrame(drawGrid);

    // Cleanup function
    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
      window.removeEventListener('resize', resizeCanvas);
    };
  }, [baseColor, activeColor, pixelSize, updateInterval]); // 의존성 배열 추가

  return (
    <div className="w-full h-full overflow-hidden">
      <canvas ref={canvasRef} className="pointer-events-none w-full h-full" />
    </div>
  );
};

export default AnimatedBackground;
!!!

## 코드: `AuthForm` 통합 부분

!!!typescript
import { Form, Link } from "@remix-run/react";
// ... other imports ...
import AnimatedBackground from "./animated-background"; // Import

// ... AuthFormProps interface ...

export function AuthForm({ type, error, pending }: AuthFormProps) {
  // ... component logic ...

  return (
    <div className="w-full lg:grid lg:min-h-[100vh] lg:grid-cols-2 xl:min-h-[100vh]">
      {/* 왼쪽 패널: AnimatedBackground 적용 */}
      <div className="hidden lg:block relative"> {/* relative 클래스 유지 */}
        <AnimatedBackground /> {/* 컴포넌트 렌더링 */}
      </div>
      {/* 오른쪽 폼 컨테이너 */}
      <div className="flex items-center justify-center py-12 min-h-screen lg:min-h-0 bg-background">
        {/* ... 오른쪽 패널 내용 ... */}
      </div>
    </div>
  );
}
!!! 