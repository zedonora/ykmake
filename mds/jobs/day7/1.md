# Day 7 - 작업 1: Jobs 테이블 스키마 및 목록 페이지 구현

`mds/tasks/day7.md`의 첫 번째 작업(#4.2, #6.4)에 따라 `jobs` 테이블 스키마를 정의하고, `/jobs` 경로에서 구인 공고 목록을 보여주는 페이지를 구현합니다.

## 1. 파일 생성 및 패키지 설치 (필요시)

Remix 라우트 파일과 데이터베이스 스키마 파일이 필요합니다.

```bash
# 라우트 파일 생성 (이미 존재하면 생략)
touch app/routes/jobs._index.tsx

# Drizzle ORM 및 관련 패키지 설치 (이미 완료되었다면 생략)
pnpm add postgres
# 이전에 설치했던 다른 드라이버는 제거해도 됩니다
# pnpm remove @neondatabase/serverless pg
```

## 2. 데이터베이스 스키마 정의 (`app/db/schema.ts`)

`jobs` 테이블 스키마를 `app/db/schema.ts` 파일에 추가합니다. `userId` 필드를 추가하여 사용자(users 테이블)와 연결합니다.

```typescript
// uuid, index 등 필요한 모듈 import 추가
import { pgTable, serial, varchar, integer, uuid, text, timestamp, bigserial, pgSchema, boolean, jsonb, uniqueIndex, index } from "drizzle-orm/pg-core";
// 실제 auth.users 테이블 참조를 위한 import (이전 단계에서 정의했다고 가정)
// import { users } from './schema'; // 또는 users 테이블이 정의된 실제 파일 경로
// auth 스키마 및 users 테이블 정의 (예시, 실제 프로젝트 구조에 맞게 조정 필요)
export const authSchema = pgSchema("auth");
// 실제 Supabase auth.users 테이블 참조 (주요 컬럼 추가)
export const users = authSchema.table("users", {
  id: uuid("id").primaryKey(),
  email: text("email"), // 사용자 이메일
  phone: text("phone"), // 사용자 전화번호
  createdAt: timestamp("created_at", { withTimezone: true }), // 생성 시각
  updatedAt: timestamp("updated_at", { withTimezone: true }), // 마지막 업데이트 시각
  lastSignInAt: timestamp("last_sign_in_at", { withTimezone: true }), // 마지막 로그인 시각
  rawUserMetaData: jsonb("raw_user_meta_data"), // 사용자 메타데이터 (커스텀 데이터 저장용)
  // --- 필요에 따라 추가할 수 있는 auth.users의 다른 컬럼들 ---
  // emailConfirmedAt: timestamp("email_confirmed_at", { withTimezone: true }),
  // phoneConfirmedAt: timestamp("phone_confirmed_at", { withTimezone: true }),
  // invitedAt: timestamp("invited_at", { withTimezone: true }),
  // confirmationToken: text("confirmation_token"), // 내부 사용 토큰
  // confirmationSentAt: timestamp("confirmation_sent_at", { withTimezone: true }),
  // recoveryToken: text("recovery_token"), // 내부 사용 토큰
  // recoverySentAt: timestamp("recovery_sent_at", { withTimezone: true }),
  // emailChangeTokenNew: text("email_change_token_new"), // 내부 사용 토큰
  // emailChange: text("email_change"),
  // emailChangeSentAt: timestamp("email_change_sent_at", { withTimezone: true }),
  // rawAppMetaData: jsonb("raw_app_meta_data"), // 앱 메타데이터 (주로 역할 등 저장)
  // isSsoUser: boolean("is_sso_user"),
  // isAnonymous: boolean("is_anonymous").default(false).notNull(), // 익명 사용자 여부 (v2.99.0 이상)
  // --- 비밀번호 관련 컬럼 (직접 접근/수정 비권장) ---
  // encryptedPassword: text("encrypted_password"),
});


// ... other table definitions ...

export const jobs = pgTable('jobs', {
  id: serial('id').primaryKey(),
  // userId 타입을 integer에서 uuid로 변경하여 users.id 타입과 일치시킴
  userId: uuid('user_id').references(() => users.id, { onDelete: 'cascade' }), // auth.users 테이블 외래키
  title: varchar('title', { length: 255 }).notNull(),
  description: text('description').notNull(),
  company: varchar('company', { length: 100 }),
  location: varchar('location', { length: 100 }),
  url: varchar('url', { length: 255 }),
  category: varchar('category', { length: 50 }), // 카테고리 필드 (예시)
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(), // 수정 시간을 위한 필드 추가 권장
}, (table) => [
  // category 및 createdAt 인덱스 (SQL 내용 반영)
  index('idx_jobs_category').on(table.category),
  index('idx_jobs_created_at').on(table.createdAt),
  // userId 컬럼 인덱스 추가 (SQL 내용 반영 및 권장)
  index('idx_jobs_user_id').on(table.userId),
]);

export type Job = typeof jobs.$inferSelect; // 조회 시 타입
export type NewJob = typeof jobs.$inferInsert; // 삽입 시 타입

// ... existing code ...
```

**참고용 SQL:**

```sql
-- jobs 테이블 생성 SQL
CREATE TABLE jobs (
    id SERIAL PRIMARY KEY,
    -- user_id 타입을 UUID로 변경하고 auth.users를 참조하도록 수정
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    company VARCHAR(100),
    location VARCHAR(100),
    url VARCHAR(255),
    category VARCHAR(50), -- 카테고리
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL -- 수정 시간
);

-- 필요시 인덱스 추가
CREATE INDEX idx_jobs_category ON jobs(category);
CREATE INDEX idx_jobs_created_at ON jobs(created_at);
-- user_id 컬럼에도 인덱스를 추가하는 것이 좋습니다.
CREATE INDEX idx_jobs_user_id ON jobs(user_id);
```

## 3. 데이터베이스 마이그레이션 실행

스키마 변경 사항을 데이터베이스에 적용합니다.

```bash
# 마이그레이션 파일 생성
pnpm drizzle-kit generate

# 마이그레이션 실행 (Neon 사용 예시, 다른 DB 사용시 수정 필요)
# pnpm drizzle-kit migrate
```

## 4. Remix 라우트 구현 (`app/routes/jobs._index.tsx`)

`/jobs` 경로에 접근했을 때 `jobs` 테이블의 데이터를 조회하여 목록 형태로 보여주는 Remix 라우트 파일을 작성합니다. Shadcn UI의 `Card` 컴포넌트를 사용하여 각 공고를 표시합니다.

```typescript
import { useLoaderData } from '@remix-run/react';
import { db } from '~/db/drizzle.server'; // Drizzle 클라이언트 import
import { jobs } from '~/db/schema'; // 스키마 import
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '~/components/ui/card'; // Shadcn UI 카드 컴포넌트
import { InferSelectModel } from 'drizzle-orm'; // 타입 추론

// Job 타입 정의 (schema.ts 에서 export 했다면 생략 가능)
// type Job = InferSelectModel<typeof jobs>;

// Loader 함수: 서버 측 데이터 로딩
export async function loader() {
  // jobs 테이블에서 최신 20개 공고를 조회
  const jobList = await db.query.jobs.findMany({
    orderBy: (jobs, { desc }) => [desc(jobs.createdAt)], // 최신순 정렬
    limit: 20, // 최대 20개 조회
    // 필요시 사용자 정보 포함 (with 사용)
    // with: {
    //   user: {
    //     columns: { name: true, email: true } // 예시: 사용자 이름과 이메일만 포함
    //   }
    // }
  });

  // Response.json 사용 (Remix 최신 방식)
  return Response.json({ jobList });
}

// 페이지 컴포넌트
export default function JobsIndex() {
  // loader에서 반환된 데이터 사용
  const { jobList } = useLoaderData<typeof loader>();

  return (
    <div className="container mx-auto py-8 px-4">
      <h1 className="text-3xl font-bold mb-6 text-center md:text-left">구인 공고</h1>
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {jobList && jobList.length > 0 ? (
          jobList.map((job) => (
            <Card key={job.id} className="flex flex-col">
              <CardHeader>
                <CardTitle className="text-lg">{job.title}</CardTitle>
                <CardDescription>
                  {job.company ? `${job.company} | ` : ''}
                  {job.location || '위치 정보 없음'}
                </CardDescription>
              </CardHeader>
              <CardContent className="flex-grow">
                <p className="text-sm text-muted-foreground mb-2">
                  카테고리: {job.category || '미지정'}
                </p>
                <p className="text-sm line-clamp-4 mb-4">
                  {job.description}
                </p>
                {job.url && (
                  <a
                    href={job.url}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-sm text-rose-600 hover:underline" // 'rose' 테마 적용
                  >
                    공고 바로가기
                  </a>
                )}
              </CardContent>
              {/* CardFooter 필요시 추가 */}
            </Card>
          ))
        ) : (
          <div className="col-span-full text-center text-muted-foreground py-10">
            등록된 구인 공고가 없습니다.
          </div>
        )}
      </div>
    </div>
  );
}
```

## 5. 에러로 drizzle server ts 파일 수정

```typescript
import { drizzle } from 'drizzle-orm/postgres-js'; // 'neon-http' 또는 'node-postgres' 대신 'postgres-js' 사용
import postgres from 'postgres'; // 'neon' 또는 'pg' 대신 'postgres' 라이브러리 사용
import * as schema from '~/db/schema'; // 정의된 스키마 임포트
import invariant from 'tiny-invariant';

const connectionString = process.env.DATABASE_URL;
invariant(connectionString, 'DATABASE_URL environment variable is not set');

// 'postgres' 클라이언트 생성
// Supabase의 Transaction pool mode 사용 시 prepare: false 필요
const client = postgres(connectionString, { prepare: false });

// 'postgres' 클라이언트와 스키마를 사용하여 Drizzle 클라이언트 생성
export const db = drizzle(client, { schema });

// 참고: postgres 라이브러리는 내부적으로 연결 풀링을 관리하므로
// 명시적인 풀 종료 코드는 일반적으로 필요하지 않습니다.
// 필요하다면 client.end()를 사용할 수 있습니다.
// process.on('exit', () => {
//   client.end();
//   console.log('Postgres.js connection closed.');
// });

```

## 6. 완료 확인

1.  `pnpm dev` 명령어로 개발 서버를 실행합니다.
2.  웹 브라우저에서 `/jobs` 경로로 접속합니다.
3.  `jobs` 테이블에 데이터가 있다면, Shadcn UI 카드 형태로 구인 공고 목록이 표시되는지 확인합니다.
4.  데이터가 없다면 "등록된 구인 공고가 없습니다." 메시지가 표시되는지 확인합니다.
5.  콘솔에 오류가 없는지 확인합니다. 