# 작업 3: 카테고리 페이지 구현 (Jobs 데이터 로딩 및 표시)

## 단계

1.  **카테고리 동적 라우트 파일 생성:**
    *   카테고리 이름을 URL 파라미터로 받는 동적 라우트 파일을 생성합니다.

    ```bash
    # 카테고리 이름을 slug 형태로 받는 것을 가정 (예: /category/frontend-development)
    touch app/routes/category.$categorySlug.tsx
    ```

2.  **`loader` 함수 구현 (카테고리별 Jobs 데이터 로딩):**
    *   `app/routes/category.$categorySlug.tsx`의 `loader` 함수를 수정합니다.
    *   `params` 객체에서 `categorySlug`를 추출하고 유효성을 검사합니다.
    *   **Drizzle `db` 클라이언트**를 사용하여 `jobs` 테이블에서 `category` 컬럼 값이 `categorySlug`와 일치하는 데이터를 조회합니다 (`where(eq(jobs.category, categorySlug))`).
    *   조회된 `jobs` 목록과 `categorySlug`를 `json`으로 반환합니다.

    ```typescript
    // app/routes/category.$categorySlug.tsx
    import { type LoaderFunctionArgs, type MetaFunction, json } from "@remix-run/node";
    import { useLoaderData, useParams } from "@remix-run/react";
    import { z } from "zod";
    import { db } from "~/lib/drizzle.server"; // Drizzle 클라이언트 import
    import { jobs } from "~/db/schema";          // jobs 스키마 import
    import type { Job } from "~/db/schema";       // Job 타입 import
    import { eq, desc } from "drizzle-orm";         // Drizzle 연산자 import

    // URL 파라미터 검증 스키마
    const ParamsSchema = z.object({
      categorySlug: z.string().min(1, "카테고리 이름이 필요합니다."),
    });

    // loader의 반환 타입 정의 (Job 목록 포함)
    type LoaderData = {
      categorySlug: string;
      categoryJobs: Job[]; // 해당 카테고리의 Job 목록
    };

    // 메타 함수에서 카테고리 이름 사용
    export const meta: MetaFunction<typeof loader> = ({ data }) => {
      const categoryName = data?.categorySlug ? data.categorySlug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) : "카테고리";
      return [
        { title: `${categoryName} 카테고리 | YkMake` },
        { name: "description", content: `${categoryName} 관련 정보` },
      ];
    };

    export const loader = async ({ params }: LoaderFunctionArgs) => {
      // Zod로 파라미터 유효성 검사
      const parsedParams = ParamsSchema.safeParse(params);
      if (!parsedParams.success) {
        throw new Response(parsedParams.error.errors[0].message, { status: 400 });
      }
      const { categorySlug } = parsedParams.data;

      try {
        // categorySlug를 사용하여 DB에서 관련 Jobs 조회
        const categoryJobs = await db.select()
            .from(jobs)
            .where(eq(jobs.category, categorySlug)) // 카테고리 필터링
            .orderBy(desc(jobs.createdAt)); // 최신순 정렬

        return json<LoaderData>({ categorySlug, categoryJobs });

      } catch (error) {
        console.error(`Error fetching jobs for category ${categorySlug}:`, error);
        // 오류 발생 시 빈 목록 반환
        return json<LoaderData>({ categorySlug, categoryJobs: [] }, { status: 500 });
      }
    };
    ```

3.  **UI 컴포넌트 구현 (Jobs 목록 표시):**
    *   `useLoaderData`를 사용하여 `categorySlug`와 `categoryJobs` 데이터를 가져옵니다.
    *   페이지 제목을 표시하고, `categoryJobs` 배열을 순회하며 각 Job 정보를 목록 형태로 표시합니다. (Jobs 목록 페이지 UI와 유사하게)

    ```typescript
    // app/routes/category.$categorySlug.tsx (Default Export 부분)
    // ... (imports, meta, loader) ...

    export default function CategoryPage() {
      const { categorySlug, categoryJobs } = useLoaderData<LoaderData>();
      const params = useParams();

      const categoryName = params.categorySlug?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || "카테고리";

      return (
        <div className="container mx-auto max-w-4xl px-4 py-8">
          <h1 className="text-3xl font-bold mb-6">{categoryName} 카테고리</h1>

          {/* 해당 카테고리의 Jobs 목록 표시 */} 
          <div className="space-y-4">
             <h2 className="text-2xl font-semibold border-b pb-2 mb-4">구인구직 ({categoryJobs.length})</h2>
            {categoryJobs.length > 0 ? (
              categoryJobs.map((job) => (
                 <div key={job.id} className="border p-4 rounded-md shadow-sm">
                  <h3 className="text-xl font-semibold mb-1">{job.title}</h3>
                  <div className="text-sm text-gray-600 mb-2">
                    <span>{job.company}</span>
                    {job.location && <> · <span>{job.location}</span></>}
                  </div>
                  <div className="text-xs text-gray-500 flex justify-between items-center">
                    <span>{job.createdAt ? new Date(job.createdAt).toLocaleDateString() : ''}</span>
                    {job.url && <a href={job.url} target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">지원하기</a>}
                  </div>
                   {/* 상세 페이지 링크 (추후 구현) */}
                  {/* <Link to={`/jobs/${job.id}`} className="absolute inset-0" /> */}
                </div>
              ))
            ) : (
              <p className="text-center text-gray-500">이 카테고리에는 아직 등록된 구인구직 정보가 없습니다.</p>
            )}
          </div>
          
          {/* TODO: 다른 카테고리 관련 정보(예: 커뮤니티 글, 아이디어) 표시 로직 추가 */} 

        </div>
      );
    }
    ```

## 완료 확인

*   `app/routes/category.$categorySlug.tsx` 파일의 `loader` 함수가 수정되어 Drizzle `db` 클라이언트를 사용하여 `jobs` 테이블에서 `categorySlug`로 필터링된 데이터를 조회하는지 확인합니다.
*   UI 컴포넌트가 수정되어 `loader`에서 반환된 `categoryJobs` 데이터를 받아 목록으로 표시하는지 확인합니다.
*   데이터베이스에 특정 카테고리(예: 'frontend')를 가진 Job 데이터를 추가합니다.
*   해당 카테고리 경로(예: `/category/frontend`)로 접속했을 때, 페이지 제목 및 내용에 카테고리 이름이 표시되고, 해당 카테고리의 Job 목록만 표시되는지 확인합니다.
*   다른 카테고리 경로(예: `/category/backend`)로 접속했을 때 해당 카테고리의 Job 목록이 표시되는지 확인합니다.
*   데이터가 없는 카테고리 경로로 접속했을 때 "등록된 구인구직 정보가 없습니다." 메시지가 표시되는지 확인합니다.
*   브라우저 탭 제목이 해당 카테고리 이름으로 동적으로 변경되는지 확인합니다 (`meta` 함수).
*   콘솔 오류가 없는지 확인합니다.
*   **남은 작업:** 현재는 Jobs 정보만 표시합니다. 필요에 따라 다른 테이블(community_posts, ideas_gpt 등)에서도 카테고리별 데이터를 조회하여 함께 표시하도록 `loader` 및 UI를 확장할 수 있습니다.

## 추가 변경사항: ThemeToggle 컴포넌트 위치 이동

*   `app/root.tsx`에 있던 `ThemeToggle` (테마 변경 버튼) 컴포넌트를 `app/components/layout/Header.tsx` 파일 내의 우측 상단 영역으로 이동시켰습니다.
*   이에 따라 `app/root.tsx`에서 관련 코드가 제거되었습니다.
*   `Header.tsx` 파일에 `ThemeToggle` 컴포넌트를 임포트하고 배치하는 코드가 추가되었습니다.

```typescript
// app/components/layout/Header.tsx (변경 부분)
import { ThemeToggle } from "~/components/theme-toggle"; // 임포트 추가

// ... 컴포넌트 내부 ...

<div className="flex items-center justify-end space-x-4">
  {/* ... 기존 로그인/로그아웃 버튼 ... */}
  <ThemeToggle /> {/* ThemeToggle 컴포넌트 추가 */} 
</div>
``` 