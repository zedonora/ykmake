# Day 20 - 작업 4: 파일/이미지 전송 기능 구현 준비

채팅 기능을 확장하여 사용자가 텍스트 메시지뿐만 아니라 파일이나 이미지도 전송할 수 있도록 준비합니다. 이를 위해 데이터베이스 스키마 변경, Supabase Storage 설정, 그리고 구현 로직을 계획합니다.

## 목표

*   채팅 메시지에 파일/이미지 첨부 정보를 저장할 수 있도록 데이터베이스 스키마를 설계합니다.
*   파일 저장을 위한 Supabase Storage 버킷 및 접근 정책을 설정합니다.
*   파일 선택, 업로드, 메시지 저장, 그리고 채팅 UI에 파일/이미지 메시지를 표시하는 전체적인 구현 흐름을 구상합니다.

## 작업 단계

### 1. 데이터베이스 스키마 설계

파일 정보를 메시지와 연결하여 저장하는 방법을 결정합니다. 두 가지 주요 접근 방식이 있습니다.

*   **방법 1: `messages` 테이블 확장 (간단한 경우)**
    *   기존 `messages` 테이블에 파일 관련 컬럼을 직접 추가합니다. 메시지 하나당 파일 하나만 첨부되는 경우 간단하게 구현할 수 있습니다.
    *   **추가 컬럼 예시**:
        *   `message_type` (Enum: 'text', 'image', 'file'): 메시지 유형 구분.
        *   `file_url` (TEXT): Supabase Storage에 업로드된 파일의 URL.
        *   `file_name` (TEXT): 원본 파일 이름.
        *   `file_type` (TEXT): 파일의 MIME 타입 (예: 'image/jpeg', 'application/pdf').
        *   `file_size` (BIGINT): 파일 크기 (bytes).
        *   `metadata` (JSONB): 이미지 썸네일 URL, 비디오 길이 등 추가 메타데이터 저장.
    ```sql
    -- message_type Enum 생성 (예시)
    DO $$
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'message_type_enum') THEN
            CREATE TYPE public.message_type_enum AS ENUM ('text', 'image', 'file');
        END IF;
    END$$;

    -- messages 테이블에 컬럼 추가 (예시)
    ALTER TABLE public.messages
    ADD COLUMN IF NOT EXISTS message_type public.message_type_enum NOT NULL DEFAULT 'text',
    ADD COLUMN IF NOT EXISTS file_url TEXT,
    ADD COLUMN IF NOT EXISTS file_name TEXT,
    ADD COLUMN IF NOT EXISTS file_type TEXT,
    ADD COLUMN IF NOT EXISTS file_size BIGINT,
    ADD COLUMN IF NOT EXISTS metadata JSONB;

    -- content 컬럼은 text 타입 메시지에만 사용되도록 nullable 변경 고려
    -- ALTER TABLE public.messages ALTER COLUMN content DROP NOT NULL; 
    -- 또는 CHECK 제약 조건 추가
    ALTER TABLE public.messages
    ADD CONSTRAINT check_message_content CHECK (
        (message_type = 'text' AND content IS NOT NULL) OR
        (message_type <> 'text' AND file_url IS NOT NULL)
    );
    ```

*   **방법 2: 별도 `attachments` 테이블 사용 (메시지당 여러 파일 또는 확장성 고려)**
    *   파일 정보를 관리하는 `attachments` 테이블을 새로 만들고, `messages` 테이블과 1:N 관계를 맺습니다. (메시지 하나에 여러 첨부파일 가능)
    *   **`attachments` 테이블 컬럼 예시**:
        *   `id` (Primary Key)
        *   `message_id` (Foreign Key to `messages.id`)
        *   `file_url`, `file_name`, `file_type`, `file_size`, `metadata` (위와 유사)
        *   `created_at`
    ```sql
    CREATE TABLE IF NOT EXISTS public.attachments (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        message_id BIGINT NOT NULL REFERENCES public.messages(id) ON DELETE CASCADE,
        file_url TEXT NOT NULL,
        file_name TEXT,
        file_type TEXT,
        file_size BIGINT,
        metadata JSONB,
        created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now())
    );

    CREATE INDEX IF NOT EXISTS idx_attachments_message_id ON public.attachments(message_id);

    -- messages 테이블 수정은 불필요 (또는 message_type 정도만 추가)
    ```

*   **선택 가이드**: 메시지당 파일 하나만 지원하고 구조를 단순하게 유지하고 싶다면 방법 1. 메시지당 여러 파일을 지원하거나 첨부파일 관련 로직/권한을 분리하고 싶다면 방법 2가 더 유연합니다. **여기서는 방법 1(messages 테이블 확장)을 기준으로 이후 단계를 설명합니다.**

### 2. Supabase Storage 설정

파일을 안전하게 저장하고 관리하기 위해 Supabase Storage를 설정합니다.

1.  **버킷(Bucket) 생성**: Supabase 대시보드 > Storage 메뉴에서 새로운 버킷을 생성합니다. (예: `chat_attachments`)
    *   Public/Private 설정: 일반적으로 채팅 첨부파일은 특정 사용자(참여자)만 접근해야 하므로 **Private 버킷**으로 설정하는 것이 좋습니다.
2.  **폴더 구조 (선택적)**: 파일을 효율적으로 관리하기 위해 폴더 구조를 계획합니다. (예: `[roomId]/[userId]/[fileName]`, `[year]/[month]/[fileName]`)
3.  **Storage 접근 정책 (RLS)**: Private 버킷의 파일에 접근할 수 있는 규칙을 설정합니다. 이는 데이터베이스 RLS와 유사하게 SQL을 사용하여 정의합니다.
    *   **업로드(INSERT) 정책**: 해당 채팅방(`roomId`)의 참여자만 특정 폴더(예: `[roomId]/`)에 파일을 업로드할 수 있도록 제한합니다.
    *   **다운로드(SELECT) 정책**: 해당 채팅방의 참여자만 해당 방 폴더 내의 파일을 다운로드(조회)할 수 있도록 제한합니다.
    *   **업데이트/삭제 정책**: 필요에 따라 파일 수정 및 삭제 권한을 설정합니다. (예: 업로드한 사용자만 삭제 가능)
    ```sql
    -- 예시: chat_attachments 버킷에 대한 정책

    -- 업로드 정책: room_id 폴더에 해당 방 참여자만 업로드 가능
    CREATE POLICY "Allow participants to upload to their room folder" 
    ON storage.objects FOR INSERT 
    WITH CHECK (
        bucket_id = 'chat_attachments' AND
        auth.role() = 'authenticated' AND
        -- 파일 경로에서 room_id 추출 (경로 규칙: room_id/...) 
        (storage.foldername(name))[1] = (
            SELECT rp.room_id::text
            FROM public.room_participants rp
            WHERE rp.user_id = auth.uid()
            AND rp.room_id::text = (storage.foldername(name))[1] -- 경로의 첫번째 폴더가 room_id와 일치하는지 확인
            LIMIT 1 -- 사용자가 참여한 방인지 확인
        )
    );

    -- 다운로드 정책: room_id 폴더의 파일은 해당 방 참여자만 다운로드 가능
    CREATE POLICY "Allow participants to download from their room folder" 
    ON storage.objects FOR SELECT 
    USING (
        bucket_id = 'chat_attachments' AND
        auth.role() = 'authenticated' AND
        (storage.foldername(name))[1] = (
            SELECT rp.room_id::text
            FROM public.room_participants rp
            WHERE rp.user_id = auth.uid()
            AND rp.room_id::text = (storage.foldername(name))[1]
            LIMIT 1
        )
    );
    ```
    *   **참고**: 위 SQL 정책 예시는 파일 경로 규칙(`[roomId]/...`)에 의존합니다. 실제 구현 시 파일 경로 규칙과 정책 조건을 정확히 맞춰야 합니다.

### 3. 구현 로직 구상

파일/이미지 전송 기능의 전체적인 흐름을 구상합니다.

*   **클라이언트 UI (`dm.$roomId.tsx`)**:
    *   **파일 선택 버튼**: 메시지 입력창 옆에 클립 아이콘 등의 버튼을 추가하여 파일 선택 대화상자를 엽니다 (`<input type="file">`).
    *   **파일 미리보기 (선택적)**: 이미지 파일의 경우, 업로드 전에 썸네일 미리보기를 표시합니다.
    *   **업로드 진행률 표시 (선택적)**: 대용량 파일 업로드 시 진행률을 시각적으로 표시합니다.
*   **클라이언트 로직 (파일 업로드)**:
    1.  사용자가 파일을 선택하면 `onChange` 이벤트 핸들러에서 파일 객체(File)를 가져옵니다.
    2.  파일 유효성 검사 (파일 크기 제한, 허용되는 파일 타입 등).
    3.  `supabase.storage.from('chat_attachments').upload(filePath, file)` 함수를 호출하여 파일을 Supabase Storage에 업로드합니다.
        *   `filePath`: Storage 내에 저장될 경로와 파일 이름. (예: `${roomId}/${auth.uid()}/${uuidv4()}-${file.name}`)
        *   업로드 옵션 (`cacheControl`, `upsert` 등) 설정 가능.
    4.  업로드 성공 시, Storage는 파일 경로(`path`)를 반환합니다.
*   **클라이언트 로직 (메시지 저장)**:
    1.  파일 업로드가 성공하면, 반환된 `path`를 사용하여 파일의 공개 URL(`publicUrl`) 또는 서명된 URL(`signedUrl`)을 생성합니다. (Private 버킷이므로 `signedUrl` 또는 RLS를 통한 직접 접근 필요)
    2.  `messages` 테이블에 새로운 메시지를 INSERT하는 로직(Action 또는 RPC)을 호출합니다. 이때 `message_type`, `file_url`(생성된 URL), `file_name`, `file_type`, `file_size` 등의 정보를 함께 전달합니다.
*   **서버 로직 (메시지 저장 - Action/RPC)**:
    *   클라이언트로부터 받은 파일 정보와 함께 `messages` 테이블에 레코드를 INSERT합니다.
    *   (방법 1 사용 시) `content`는 NULL로 설정하고 파일 관련 컬럼에 값을 채웁니다.
    *   (방법 2 사용 시) `messages` 레코드 INSERT 후 반환된 `message_id`를 사용하여 `attachments` 테이블에 파일 정보를 INSERT합니다.
*   **클라이언트 UI (메시지 표시)**:
    *   채팅 메시지 목록을 렌더링하는 컴포넌트에서 `message.message_type`을 확인합니다.
    *   **이미지(`image`)**: `<img>` 태그를 사용하여 `message.file_url`의 이미지를 표시합니다.
    *   **파일(`file`)**: 파일 아이콘, 파일 이름(`message.file_name`), 파일 크기(`message.file_size`), 다운로드 링크(`<a>` 태그, `href=message.file_url`) 등을 표시합니다.
    *   **텍스트(`text`)**: 기존처럼 `message.content`를 표시합니다.

## 예상 결과

*   데이터베이스 스키마가 파일/이미지 정보를 저장할 수 있도록 준비됩니다.
*   Supabase Storage 버킷이 생성되고, 채팅방 참여자만 파일을 업로드하고 접근할 수 있도록 보안 정책이 설정됩니다.
*   파일 선택부터 업로드, 메시지 저장, UI 표시까지 전체 구현 흐름에 대한 계획이 수립됩니다.

## 체크리스트

*   [ ] `messages` 테이블 확장 또는 `attachments` 테이블 생성 등 스키마 설계 방안이 결정되었는가?
*   [ ] 선택된 스키마 변경 SQL(컬럼 추가 또는 테이블 생성)이 준비되었는가?
*   [ ] Supabase Storage 버킷(`chat_attachments`)이 생성되었는가? (Private 권장)
*   [ ] Storage 접근 정책(업로드/다운로드 RLS)이 설계 및 준비되었는가?
*   [ ] 클라이언트 UI에 파일 선택 버튼 및 관련 UI 요소 추가 계획이 수립되었는가?
*   [ ] 클라이언트에서 파일 유효성 검사 및 `supabase.storage.upload()` 호출 로직이 구상되었는가?
*   [ ] 파일 업로드 성공 후 파일 URL 생성 및 메시지 저장 로직(Action/RPC) 호출 계획이 수립되었는가?
*   [ ] 서버 측 메시지 저장 로직(Action/RPC)에서 파일 정보를 처리하는 방식이 구상되었는가?
*   [ ] 채팅 UI에서 `message_type`에 따라 이미지, 파일 링크, 텍스트를 다르게 표시하는 로직이 구상되었는가?

``` 