# Day 20 - 작업 1: 그룹 채팅 기초 구현 (스키마 확장)

기존 1:1 DM 기능을 확장하여 여러 사용자가 참여할 수 있는 그룹 채팅 기능의 기반을 마련합니다. 이를 위해 데이터베이스 스키마를 수정하고 관련 RLS 정책을 업데이트합니다.

## 목표

*   1:1 DM과 그룹 채팅을 모두 지원할 수 있도록 데이터베이스 스키마를 확장합니다.
*   채팅방 참여자를 관리하는 별도의 테이블을 도입합니다.
*   변경된 스키마에 맞춰 RLS 정책을 업데이트하여 그룹 채팅 환경에서도 데이터 접근 보안을 유지합니다.

## 작업 단계

### 1. 데이터베이스 스키마 변경

기존 `rooms` 테이블을 수정하여 그룹 채팅을 지원하도록 확장하고, 참여자 관리를 위한 `room_participants` 테이블을 새로 생성합니다.

*   **`rooms` 테이블 수정**:
    *   **`room_type` 컬럼 추가**: 방의 종류를 구분하기 위한 Enum 타입 컬럼 (예: `dm`, `group`).
        ```sql
        -- 방 타입 Enum 생성 (이미 존재하지 않는 경우)
        DO $$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'room_type_enum') THEN
                CREATE TYPE public.room_type_enum AS ENUM ('dm', 'group');
            END IF;
        END$$;

        -- rooms 테이블에 room_type 컬럼 추가
        ALTER TABLE public.rooms
        ADD COLUMN IF NOT EXISTS room_type public.room_type_enum NOT NULL DEFAULT 'dm'; -- 기존 방은 dm으로 가정
        ```
    *   **`name` 컬럼 추가**: 그룹 채팅방의 이름을 저장할 컬럼 (DM의 경우 NULL 허용).
        ```sql
        ALTER TABLE public.rooms
        ADD COLUMN IF NOT EXISTS name TEXT;
        ```
    *   **`created_by` 컬럼 추가**: 그룹 채팅방을 생성한 사용자의 ID를 저장할 컬럼 (DM의 경우 NULL 허용).
        ```sql
        ALTER TABLE public.rooms
        ADD COLUMN IF NOT EXISTS created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL;
        ```
    *   **`participant1_id`, `participant2_id` 컬럼 제거**: 참여자 정보는 `room_participants` 테이블에서 관리하므로 제거합니다. **주의: 이 컬럼들을 사용하는 기존 로직 수정이 반드시 필요합니다!**
        ```sql
        -- 주의: 이 컬럼들을 사용하는 로직(예: 쿼리, RLS 정책)을 먼저 수정해야 합니다.
        -- 기존 데이터 마이그레이션 후 컬럼 제거
        -- ALTER TABLE public.rooms DROP COLUMN IF EXISTS participant1_id;
        -- ALTER TABLE public.rooms DROP COLUMN IF EXISTS participant2_id;
        -- TODO: 실제 컬럼 제거 전, 기존 DM 방 데이터를 room_participants로 마이그레이션하는 스크립트 필요
        ```
*   **`room_participants` 테이블 생성**:
    *   어떤 사용자가 어떤 방에 참여하는지를 나타내는 중간 테이블.
    *   `room_id`, `user_id` 복합 기본 키 또는 별도 `id` 컬럼 + unique 제약조건.
        ```sql
        CREATE TABLE IF NOT EXISTS public.room_participants (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            room_id BIGINT NOT NULL REFERENCES public.rooms(id) ON DELETE CASCADE,
            user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
            joined_at TIMESTAMPTZ NOT NULL DEFAULT timezone('utc'::text, now()),
            -- 역할(role) 등 추가 컬럼 고려 가능
            -- role TEXT CHECK (role IN ('admin', 'member')) DEFAULT 'member',
            created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()),

            -- 한 사용자가 같은 방에 중복 참여 방지
            UNIQUE (room_id, user_id)
        );

        -- 인덱스 추가 (참여자 기반 방 조회, 방 기반 참여자 조회)
        CREATE INDEX IF NOT EXISTS idx_room_participants_user_id ON public.room_participants(user_id);
        CREATE INDEX IF NOT EXISTS idx_room_participants_room_id ON public.room_participants(room_id);
        ```
*   **기존 DM 데이터 마이그레이션 (중요!)**: `rooms` 테이블에서 `participant1_id`, `participant2_id` 컬럼을 제거하기 전에, 기존 DM 채팅방 정보를 `room_participants` 테이블로 옮겨야 합니다. 각 DM 방에 대해 두 참가자를 `room_participants`에 INSERT하는 스크립트를 작성하고 실행합니다.
    ```sql
    -- 예시 마이그레이션 스크립트 (실행 전 백업 및 테스트 필수!)
    INSERT INTO public.room_participants (room_id, user_id)
    SELECT id, participant1_id FROM public.rooms WHERE room_type = 'dm' AND participant1_id IS NOT NULL
    ON CONFLICT (room_id, user_id) DO NOTHING;

    INSERT INTO public.room_participants (room_id, user_id)
    SELECT id, participant2_id FROM public.rooms WHERE room_type = 'dm' AND participant2_id IS NOT NULL
    ON CONFLICT (room_id, user_id) DO NOTHING;

    -- 마이그레이션 확인 후 participant 컬럼 제거 진행
    -- ALTER TABLE public.rooms DROP COLUMN IF EXISTS participant1_id;
    -- ALTER TABLE public.rooms DROP COLUMN IF EXISTS participant2_id;
    ```

### 2. RLS 정책 업데이트

변경된 스키마 구조에 맞게 RLS(Row Level Security) 정책을 업데이트하여, 사용자가 자신이 참여한 방의 정보와 메시지만 접근할 수 있도록 보장합니다.

*   **`rooms` 테이블 RLS**: 사용자가 `room_participants` 테이블을 통해 해당 `room_id`에 참여하고 있는지 확인하도록 수정합니다.
    ```sql
    -- rooms 테이블 SELECT 정책 예시
    ALTER POLICY "Allow authenticated users to select their rooms" ON public.rooms
    FOR SELECT
    USING (
      auth.role() = 'authenticated' AND
      EXISTS (
        SELECT 1
        FROM public.room_participants rp
        WHERE rp.room_id = public.rooms.id
          AND rp.user_id = auth.uid()
      )
    );

    -- rooms 테이블 INSERT 정책 예시 (그룹방 생성)
    -- 그룹방 생성은 별도 로직(RPC 등)으로 처리하고, 해당 로직 내에서 participants 추가 권장
    -- INSERT 정책은 좀 더 신중하게 설계 필요 (예: 특정 조건 만족 시 허용)
    -- 임시: 인증된 사용자는 group 타입 방 생성 가능 (created_by 자신)
    DROP POLICY IF EXISTS "Allow authenticated users to insert rooms" ON public.rooms;
    CREATE POLICY "Allow authenticated users to insert group rooms" ON public.rooms
    FOR INSERT
    WITH CHECK (
      auth.role() = 'authenticated' AND
      room_type = 'group' AND
      created_by = auth.uid()
      -- TODO: 추가적인 생성 조건 검토
    );
    ```
*   **`messages` 테이블 RLS**: 메시지가 속한 `room_id`에 사용자가 참여하고 있는지 `room_participants` 테이블을 통해 확인하도록 수정합니다.
    ```sql
    -- messages 테이블 SELECT 정책 예시
    ALTER POLICY "Allow participants to select messages in their rooms" ON public.messages
    FOR SELECT
    USING (
      auth.role() = 'authenticated' AND
      EXISTS (
        SELECT 1
        FROM public.room_participants rp
        WHERE rp.room_id = public.messages.room_id
          AND rp.user_id = auth.uid()
      )
    );

    -- messages 테이블 INSERT 정책 예시
    ALTER POLICY "Allow participants to insert messages in their rooms" ON public.messages
    FOR INSERT
    WITH CHECK (
      auth.role() = 'authenticated' AND
      user_id = auth.uid() AND
      EXISTS (
        SELECT 1
        FROM public.room_participants rp
        WHERE rp.room_id = public.messages.room_id
          AND rp.user_id = auth.uid()
      )
    );
    ```
*   **`room_participants` 테이블 RLS**: 사용자는 자신이 참여한 방의 참여자 정보만 보거나, 특정 조건(예: 같은 방 참여자) 하에 다른 참여자 정보를 볼 수 있도록 설정합니다. 방 나가기/초대 등을 위해 UPDATE/DELETE 정책도 필요합니다.
    ```sql
    -- room_participants 테이블 SELECT 정책 예시 (같은 방 참여자 정보 조회 허용)
    CREATE POLICY "Allow participants to select participants in their rooms" ON public.room_participants
    FOR SELECT
    USING (
      auth.role() = 'authenticated' AND
      EXISTS (
        SELECT 1
        FROM public.room_participants rp_self
        WHERE rp_self.room_id = public.room_participants.room_id
          AND rp_self.user_id = auth.uid()
      )
    );

    -- room_participants 테이블 INSERT 정책 예시 (그룹방 생성 시 또는 초대 기능 통해)
    -- 그룹방 생성 로직과 연동 필요. 초대 기능 구현 시 별도 정책 필요.
    -- 임시: 사용자가 속한 방에 다른 사용자를 추가하는 것은 별도 RPC 권장
    CREATE POLICY "Allow insert for room creator or via RPC" ON public.room_participants
    FOR INSERT
    WITH CHECK (
        auth.role() = 'authenticated'
        -- TODO: 초대 로직 또는 방 생성 로직과 연계하여 정책 구체화
        -- 예: EXISTS (SELECT 1 FROM rooms r WHERE r.id = room_id AND r.created_by = auth.uid())
        -- 또는 특정 RPC 함수 내에서만 INSERT 허용
    );

    -- room_participants 테이블 DELETE 정책 예시 (자기 자신만 나가기 허용)
    CREATE POLICY "Allow users to delete their own participation" ON public.room_participants
    FOR DELETE
    USING (
        auth.role() = 'authenticated' AND
        user_id = auth.uid()
    );
    ```

### 3. 기본 기능 구현 방향

*   **그룹 채팅방 생성**: 사용자가 방 이름과 초기 참여자를 선택하여 그룹 채팅방을 생성하는 UI 및 서버 로직(Remix Action 또는 Supabase RPC)을 구현합니다.
    *   서버 로직에서는 `rooms` 테이블에 `room_type='group'`으로 새 방을 INSERT하고, `room_participants` 테이블에 생성자와 초기 참여자를 INSERT합니다.
*   **채팅방 목록 조회**: `loader` 함수에서 사용자가 참여한 모든 방(`room_participants` 기준) 목록을 가져오도록 쿼리를 수정합니다. DM방과 그룹방을 구분하여 표시할 수 있습니다.

## 예상 결과

*   데이터베이스 스키마가 1:1 DM과 그룹 채팅을 모두 지원하도록 확장됩니다.
*   `room_participants` 테이블을 통해 채팅방 참여자 정보가 관리됩니다.
*   업데이트된 RLS 정책에 따라 사용자는 자신이 참여한 방의 데이터에만 안전하게 접근할 수 있습니다.
*   그룹 채팅 기능을 구현하기 위한 데이터베이스 기반이 마련됩니다.

## 체크리스트

*   [ ] `rooms` 테이블에 `room_type`, `name`, `created_by` 컬럼이 추가되었는가?
*   [ ] `room_participants` 테이블이 생성되고 필요한 컬럼 및 제약 조건이 설정되었는가?
*   [ ] 기존 DM 방 데이터가 `room_participants` 테이블로 마이그레이션 되었는가? (마이그레이션 후 `participant1_id`, `participant2_id` 컬럼 제거)
*   [ ] `rooms` 테이블의 RLS 정책이 `room_participants`를 참조하도록 업데이트되었는가?
*   [ ] `messages` 테이블의 RLS 정책이 `room_participants`를 참조하도록 업데이트되었는가?
*   [ ] `room_participants` 테이블에 대한 적절한 RLS 정책(SELECT, INSERT, DELETE 등)이 설정되었는가?
*   [ ] (다음 작업) 그룹 채팅방 생성 기능 구현 계획 수립
*   [ ] (다음 작업) 채팅방 목록 조회 로직 수정 계획 수립

# Day 20 - 작업 1: IdeasGPT 페이지 상세 구현

## 필요한 파일 생성 및 패키지 설치

```bash
# 필요한 디렉토리 생성
mkdir -p app/routes/ideas
mkdir -p app/components/ideas

# 필요한 Shadcn UI 컴포넌트 설치
pnpx shadcn@latest add button card textarea tabs skeleton toast
```

## IdeasGPT 페이지 라우트 생성

```tsx
// app/routes/ideas._index.tsx
import { Outlet } from "@remix-run/react";
import { IdeasHeader } from "~/components/ideas/IdeasHeader";
import { IdeasGPTPrompt } from "~/components/ideas/IdeasGPTPrompt";
import { IdeasGallery } from "~/components/ideas/IdeasGallery";

export default function IdeasPage() {
  return (
    <div className="container py-8">
      <IdeasHeader 
        title="IdeasGPT" 
        description="AI가 당신의 다음 프로젝트 아이디어를 제안해드립니다. 원하는 아이디어를 구매하거나 생성할 수 있습니다."
      />
      
      <div className="grid gap-8 md:grid-cols-[1fr_300px] lg:grid-cols-[1fr_350px]">
        <IdeasGPTPrompt />
        <IdeasGallery />
      </div>
      
      <Outlet />
    </div>
  );
}
```

## IdeasHeader 컴포넌트 작성

```tsx
// app/components/ideas/IdeasHeader.tsx
import { FC } from "react";

interface IdeasHeaderProps {
  title: string;
  description: string;
}

export const IdeasHeader: FC<IdeasHeaderProps> = ({ title, description }) => {
  return (
    <div className="mb-8">
      <h1 className="text-3xl font-bold tracking-tight">{title}</h1>
      <p className="text-muted-foreground mt-2">{description}</p>
    </div>
  );
};
```

## IdeasGPTPrompt 컴포넌트 작성

```tsx
// app/components/ideas/IdeasGPTPrompt.tsx
import { useState } from "react";
import { Button } from "~/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "~/components/ui/card";
import { Textarea } from "~/components/ui/textarea";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "~/components/ui/tabs";
import { Loader2Icon } from "lucide-react";

export function IdeasGPTPrompt() {
  const [prompt, setPrompt] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!prompt || isLoading) return;
    
    setIsLoading(true);
    // OpenAI API 연동 로직은 작업 3에서 구현
    // 테스트를 위한 타임아웃 추가
    setTimeout(() => {
      setIsLoading(false);
    }, 2000);
  };

  return (
    <Card className="col-span-1">
      <CardHeader>
        <CardTitle>아이디어 생성</CardTitle>
        <CardDescription>
          지시문을 입력하고 AI가 당신의 아이디어를 생성하도록 해보세요
        </CardDescription>
      </CardHeader>
      
      <form onSubmit={handleSubmit}>
        <CardContent>
          <Tabs defaultValue="simple">
            <TabsList className="mb-4">
              <TabsTrigger value="simple">간단 모드</TabsTrigger>
              <TabsTrigger value="advanced">고급 모드</TabsTrigger>
            </TabsList>
            
            <TabsContent value="simple" className="space-y-4">
              <div>
                <Textarea
                  placeholder="어떤 종류의 아이디어를 생성하고 싶으신가요? (예: AI를 활용한 교육 앱 아이디어)"
                  value={prompt}
                  onChange={(e) => setPrompt(e.target.value)}
                  rows={5}
                  className="resize-none"
                />
              </div>
            </TabsContent>
            
            <TabsContent value="advanced" className="space-y-4">
              <div>
                <Textarea
                  placeholder="세부적인 요구사항을 작성해보세요. (예: 대상 연령층, 해결하려는 문제, 중점 기능 등)"
                  value={prompt}
                  onChange={(e) => setPrompt(e.target.value)}
                  rows={7}
                  className="resize-none"
                />
              </div>
            </TabsContent>
          </Tabs>
        </CardContent>
        
        <CardFooter>
          <Button type="submit" className="w-full" disabled={!prompt || isLoading}>
            {isLoading ? (
              <>
                <Loader2Icon className="mr-2 h-4 w-4 animate-spin" />
                생성 중...
              </>
            ) : "아이디어 생성하기"}
          </Button>
        </CardFooter>
      </form>
    </Card>
  );
}
```

## IdeasGallery 컴포넌트 작성 

```tsx
// app/components/ideas/IdeasGallery.tsx
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "~/components/ui/card";
import { Skeleton } from "~/components/ui/skeleton";

// 작업 3에서 실제 데이터로 대체됨
const placeholderIdeas = [
  { id: "1", title: "AI 기반 학습 관리 시스템", description: "학생들의 학습 패턴을 분석하여 맞춤형 학습 경로를 제공하는 플랫폼" },
  { id: "2", title: "지역 농산물 직거래 마켓플레이스", description: "지역 농부들이 소비자에게 직접 판매할 수 있는 디지털 마켓플레이스" },
];

export function IdeasGallery() {
  return (
    <Card className="col-span-1 h-fit">
      <CardHeader>
        <CardTitle>최근 생성된 아이디어</CardTitle>
        <CardDescription>다른 사용자들이 최근에 생성한 아이디어들</CardDescription>
      </CardHeader>
      
      <CardContent className="space-y-4">
        {placeholderIdeas.map((idea) => (
          <div key={idea.id} className="border rounded-md p-3 hover:bg-accent transition-colors cursor-pointer">
            <h3 className="font-medium text-sm">{idea.title}</h3>
            <p className="text-muted-foreground text-xs mt-1 line-clamp-2">{idea.description}</p>
          </div>
        ))}
        
        {/* 로딩 상태 스켈레톤 UI */}
        <div className="border rounded-md p-3">
          <Skeleton className="h-4 w-3/4 mb-2" />
          <Skeleton className="h-3 w-full mb-1" />
          <Skeleton className="h-3 w-5/6" />
        </div>
      </CardContent>
    </Card>
  );
}
```

## 테이블 스키마 생성

DB 스키마 파일에 아이디어 테이블 추가:

```tsx
// app/db/schema.ts에 추가
// ... 기존 스키마 코드 ...

export const ideas = pgTable(
  "ideas",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    title: text("title").notNull(),
    description: text("description").notNull(),
    details: text("details"),
    creatorId: uuid("creator_id").references(() => users.id, { onDelete: "cascade" }),
    ownerId: uuid("owner_id").references(() => users.id, { onDelete: "set null" }),
    isPublic: boolean("is_public").default(false),
    price: integer("price").default(0),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
  },
  (table) => {
    return {
      creatorIdIdx: index("ideas_creator_id_idx").on(table.creatorId),
      ownerIdIdx: index("ideas_owner_id_idx").on(table.ownerId),
    };
  }
);

// 필요한 관계 타입들 export
export type Idea = typeof ideas.$inferSelect;
export type NewIdea = typeof ideas.$inferInsert;
```

## 완료 확인

1. 다음 명령으로 drizzle 마이그레이션을 실행합니다.
```bash
pnpm run drizzle:generate
```

2. 개발 서버를 실행하고 `/ideas` 경로로 접속합니다.
```bash
pnpm run dev
```

3. 브라우저에서 http://localhost:5173/ideas 접속
   - 아이디어 생성 폼과 최근 생성된 아이디어 목록이 표시되는지 확인
   - 간단 모드와 고급 모드 탭 전환이 정상 작동하는지 확인
   - 텍스트 입력 후 버튼 클릭 시 로딩 상태가 정상 작동하는지 확인

``` 